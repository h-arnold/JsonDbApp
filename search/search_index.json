{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"JsonDbApp","text":"<p>A document database implemented in Google Apps Script using the Google Drive API with no external dependencies. Capable of storing any serialisable data in a JSON file. Supports a limited subset of MongoDB syntax for CRUD operations on named collections, with data consistency managed through a ScriptProperties-based master index.</p>"},{"location":"#who-is-this-for","title":"Who is this for?","text":"<ul> <li>You want a database with no external dependencies.</li> <li>You want to develop a project in GAS which handles sensitive data without having to worry about external data security.</li> <li>You don't want to be endlessly debugging issues with transforming data structures to fit into a spreadsheet.</li> <li>Your datasets are relatively small (collections no larger than 2GB so as not to exceed the GAS memory limits).</li> <li>Traffic for your app is relatively low.</li> </ul>"},{"location":"#why-jsondbapp","title":"Why JsonDbApp?","text":"<p>Avoid transforming data structures to fit on a Google Sheet: Once your data structures start getting a little more complex, storing the data in tables as you would in a relational database becomes brittle and error-prone. As you'll likely transform the data into a JSON structure anyway, why not just store it that way in the first place?</p> <p>More performant than storing data in a Google Sheet: The largest bottleneck in GAS is the number of API calls you make. By storing data in a single (or a few) JSON files, you greatly reduce the number of API calls you need to make. Manipulating relatively large amounts of data in memory is much faster.</p> <p>You can't just hoik your data into a proper database: If you can store your data in a proper database, do. If, like me, your org doesn't allow you to do that, or you don't want to have to manage the security implications of doing so, this is the next best thing.</p> <p>You've normalised your class structures already, dammit!: And you'll be damned if you have to normalise them to fit into a relational database, or worse, a spreadsheet.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Make a copy of this project in your Google Drive.</p> <ul> <li>If you plan on doing development work, use the version with tests.</li> <li>If you just plan on using the library, use the version without tests. This makes the file much smaller and faster to load.</li> </ul> <p>Connect this project as a Library in your Apps Script project (Resources &gt; Libraries...).</p> <p>Public API functions exposed by the library identifier (e.g. <code>JsonDbApp</code>):</p> <ul> <li><code>createAndInitialiseDatabase(config)</code> \u2013 First-time setup; creates a new MasterIndex and initialises the DB</li> <li><code>loadDatabase(config)</code> \u2013 Load an existing database (MasterIndex must already exist)</li> </ul>"},{"location":"#basic-example","title":"Basic Example","text":"<pre><code>// First-time setup\nfunction setupDb() {\n  const db = JsonDbApp.createAndInitialiseDatabase({\n    masterIndexKey: 'myMasterIndex',\n    lockTimeout: 5000\n  });\n  // db is initialised and ready to use\n}\n\n// Load existing database\nfunction getDb() {\n  const config = {\n    masterIndexKey: 'myMasterIndex'\n    // rootFolderId: 'your-folder-id', // optional; where new files/backups are created\n    // lockTimeout: 5000,              // optional; override defaults as needed\n    // logLevel: 'INFO'                // optional\n  };\n  const db = JsonDbApp.loadDatabase(config);\n  return db;\n}\n\n// Work with a collection\nfunction demo() {\n  const db = JsonDbApp.loadDatabase({ masterIndexKey: 'myMasterIndex' });\n  const users = db.collection('users'); // auto-creates if enabled (default true)\n  users.insertOne({ _id: 'u1', name: 'Ada', role: 'admin' });\n  users.save(); // persist changes to Drive\n  const admins = users.find({ role: 'admin' });\n  console.log(JSON.stringify(admins));\n}\n</code></pre> <p>!!! note - Use <code>masterIndexKey</code> (not <code>masterIndexName</code>). - Avoid <code>JSON.stringify(db)</code>; inspect specific values instead (e.g. <code>db.listCollections()</code>). - Write operations are in-memory until you call <code>collection.save()</code>. Batch multiple writes, then <code>save()</code> once to persist to Drive.</p>"},{"location":"#supported-query-operators","title":"Supported Query Operators","text":"<p>Current query support focuses on a small, fast subset:</p> <ul> <li>Comparison: <code>$eq</code>, <code>$gt</code>, <code>$lt</code></li> <li>Logical: <code>$and</code>, <code>$or</code></li> </ul> <p>!!! info - Multiple top-level fields are implicitly ANDed (e.g. <code>{ a: 1, b: 2 }</code>). - Nested fields are supported via dot notation (e.g. <code>\"profile.department\"</code>). - Equality against arrays treats a scalar as a membership test (MongoDB-style).</p> <p>For detailed examples and usage, see the Querying Guide.</p>"},{"location":"#supported-update-operators","title":"Supported Update Operators","text":"<p>Implemented MongoDB-style update operators:</p> <ul> <li>Field: <code>$set</code>, <code>$unset</code></li> <li>Numeric: <code>$inc</code>, <code>$mul</code>, <code>$min</code>, <code>$max</code></li> <li>Array: <code>$push</code>, <code>$pull</code>, <code>$addToSet</code></li> </ul> <p>!!! info - Dot notation is supported for nested fields (e.g. <code>\"profile.name\"</code>). - <code>$push</code> and <code>$addToSet</code> support the <code>$each</code> modifier for multiple values. - <code>$addToSet</code> enforces uniqueness; creates the array if missing; errors if target exists and isn't an array. - <code>$push</code> creates the array if missing; errors if target exists and isn't an array. - <code>$pull</code> removes matching elements; non-array or missing targets are a no-op. Object criteria support simple field predicates and basic comparison operators.</p> <p>For detailed examples and usage, see the Updates Guide.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get up and running quickly</li> <li>Examples - More detailed usage examples</li> <li>Querying Guide - Comprehensive guide to queries</li> <li>Updates Guide - Comprehensive guide to updates</li> <li>Developer Documentation - Architecture and technical details</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<ol> <li>Refactoring - code isn't as tidy as I would like it to be, some classes are too large and the testing framework was made up as I went along so could do with some work.</li> <li>Implement file caching using the GAS <code>CacheService</code> to speed up read and write operations.</li> <li>Implement collection indexing to speed up query operations, especially across collections.</li> <li>Implement schema creation and validation. For now, you can store any object with a <code>fromJSON</code> and a <code>toJSON</code> method, but it would be good to be able to define and enforce a schema.</li> <li>Expand query and update operator support to cover a larger subset of MongoDB syntax.</li> <li>Add user access levels - at the moment, access is handled by Google Drive File permissions. It would be good to have more granular control over user access.</li> <li>A GAS WebApp query interface for testing and debugging queries.</li> </ol>"},{"location":"Examples/","title":"Detailed Examples","text":"<ul> <li>Detailed Examples</li> <li>Overview</li> <li>Configuration Variants</li> <li>Collection Lifecycle</li> <li>Read and Query Patterns</li> <li>Write Patterns</li> <li>Aggregation (Match-Only)</li> <li>Index Backup Workflow</li> </ul>"},{"location":"Examples/#overview","title":"Overview","text":"<p>These examples show end-to-end usage patterns, including configuration, CRUD, and query workflows. They assume the JsonDbApp library is attached to your Apps Script project.</p>"},{"location":"Examples/#configuration-variants","title":"Configuration Variants","text":"<pre><code>// Default configuration\nconst defaultConfig = new DatabaseConfig();\n\n// Production-oriented configuration\nconst config = new DatabaseConfig({\n  rootFolderId: 'YOUR_DRIVE_FOLDER_ID',\n  autoCreateCollections: false,\n  lockTimeout: 15000,\n  retryAttempts: 5,\n  logLevel: 'INFO',\n  backupOnInitialise: true\n});\n</code></pre>"},{"location":"Examples/#collection-lifecycle","title":"Collection Lifecycle","text":"<pre><code>const db = JsonDbApp.createAndInitialiseDatabase(config);\n\n// Create or fetch collections\nconst orders = db.createCollection('orders');\nconst customers = db.getCollection('customers');\n\n// List collections\nconst allCollections = db.listCollections();\n\n// Drop a collection when it is no longer needed\nconst removed = db.dropCollection('legacy_orders');\n</code></pre>"},{"location":"Examples/#read-and-query-patterns","title":"Read and Query Patterns","text":"<pre><code>// Simple equality\nconst openOrders = orders.find({ status: 'open' });\n\n// Comparison operators\nconst highValue = orders.find({ total: { $gt: 1000 } });\n\n// Logical operators\nconst priority = orders.find({\n  $and: [{ status: 'open' }, { total: { $gt: 500 } }]\n});\n\n// Count documents\nconst openCount = orders.countDocuments({ status: 'open' });\n</code></pre>"},{"location":"Examples/#write-patterns","title":"Write Patterns","text":"<pre><code>// Insert\nconst insertResult = orders.insertOne({\n  customerId: 'cust_123',\n  total: 240,\n  status: 'open'\n});\n\n// Update with operators\norders.updateOne({ _id: insertResult.insertedId }, { $set: { status: 'paid' } });\n\n// Replace a document entirely\norders.replaceOne(\n  { _id: insertResult.insertedId },\n  {\n    _id: insertResult.insertedId,\n    customerId: 'cust_123',\n    total: 240,\n    status: 'archived'\n  }\n);\n\n// Update multiple documents\norders.updateMany({ status: 'open' }, { $set: { reviewed: true } });\n\n// Delete patterns\norders.deleteOne({ _id: insertResult.insertedId });\norders.deleteMany({ status: 'archived' });\n\n// Persist changes\norders.save();\n</code></pre>"},{"location":"Examples/#aggregation-match-only","title":"Aggregation (Match-Only)","text":"<p>The aggregation pipeline currently supports a <code>$match</code> stage for filtering.</p> <pre><code>const matched = orders.aggregate([{ $match: { status: 'open' } }]);\n</code></pre>"},{"location":"Examples/#index-backup-workflow","title":"Index Backup Workflow","text":"<pre><code>const db = JsonDbApp.loadDatabase(config);\n\n// Ensure the Drive index file exists and load it\nconst indexData = db.loadIndex();\n\n// Back up MasterIndex data to Drive explicitly\nconst backedUp = db.backupIndexToDrive();\n</code></pre>"},{"location":"Querying/","title":"Querying Collections","text":"<ul> <li>Querying Collections</li> <li>Overview</li> <li>Basic Query Syntax</li> <li>Comparison Operators<ul> <li>$eq - Equality</li> <li>$gt - Greater Than</li> <li>$gte - Greater Than or Equal</li> <li>$lt - Less Than</li> <li>$lte - Less Than or Equal</li> <li>$ne - Not Equal</li> <li>$in - Match Any Value in Array</li> <li>$nin - Match No Values in Array</li> </ul> </li> <li>Logical Operators<ul> <li>$and - Logical AND</li> <li>$or - Logical OR</li> <li>$nor - Logical NOR</li> <li>$not - Logical NOT</li> <li>Combining Logical Operators</li> </ul> </li> <li>Querying Nested Fields<ul> <li>Dot Notation</li> <li>Nested Object Equality</li> <li>Deep Nesting</li> </ul> </li> <li>Array Queries<ul> <li>Matching Array Values</li> <li>Empty Arrays</li> <li>Array Length</li> </ul> </li> <li>Edge Cases and Special Values<ul> <li>Null Values</li> <li>Zero and False</li> <li>Empty Strings</li> <li>Missing Fields</li> </ul> </li> <li>Query Performance Tips</li> <li>Complete Examples</li> </ul>"},{"location":"Querying/#overview","title":"Overview","text":"<p>JsonDbApp provides MongoDB-compatible query operators for finding documents in collections. Queries are expressed as JavaScript objects where field names map to matching criteria. This guide covers all supported query operators with practical examples.</p>"},{"location":"Querying/#basic-query-syntax","title":"Basic Query Syntax","text":"<p>Simple equality queries match documents where a field equals a specific value:</p> <pre><code>const users = db.getCollection('users');\n\n// Find by exact match\nconst activeUsers = users.find({ isActive: true });\n\n// Find by _id\nconst user = users.findOne({ _id: 'user123' });\n\n// Find by nested field using dot notation\nconst anna = users.findOne({ 'name.first': 'Anna' });\n</code></pre>"},{"location":"Querying/#comparison-operators","title":"Comparison Operators","text":"<p>Comparison operators evaluate field values against specified criteria.</p>"},{"location":"Querying/#eq-equality","title":"$eq - Equality","text":"<p>Matches documents where a field equals a specified value. Explicit <code>$eq</code> is optional\u2014implicit equality works the same way.</p> <pre><code>// Arrange - persons collection with various ages\nconst persons = db.getCollection('persons');\n\n// Act - find person aged exactly 29\nconst results = persons.find({ age: { $eq: 29 } });\n// Equivalent implicit syntax\nconst results2 = persons.find({ age: 29 });\n\n// Assert\nconsole.log(results[0]._id); // 'person1'\n</code></pre> <p>Edge Cases:</p> <pre><code>// Zero is distinct from false\nconst zeroAge = persons.find({ age: { $eq: 0 } });\nconst falseActive = persons.find({ isActive: { $eq: false } });\n\n// Null matching\nconst noLogin = persons.find({ lastLogin: { $eq: null } });\n\n// Date matching requires exact timestamp\nconst targetDate = new Date('2025-06-20T10:30:00Z');\nconst loginMatch = persons.find({ lastLogin: { $eq: targetDate } });\n\n// Empty string vs null\nconst emptyEmail = persons.find({ 'contact.email': { $eq: '' } });\nconst nullEmail = persons.find({ 'contact.email': { $eq: null } });\n</code></pre>"},{"location":"Querying/#gt-greater-than","title":"$gt - Greater Than","text":"<p>Matches documents where a field value is greater than the specified value.</p> <pre><code>// Numeric comparisons\nconst olderPersons = persons.find({ age: { $gt: 40 } });\n\n// Float comparisons\nconst highScores = persons.find({ score: { $gt: 90.0 } });\n\n// Mixed integer and float\nconst aboveThreshold = persons.find({ score: { $gt: 80 } });\n\n// Negative numbers\nconst positiveBalance = persons.find({ balance: { $gt: -200 } });\n\n// Zero boundary\nconst creditBalance = persons.find({ balance: { $gt: 0 } });\n\n// Date comparisons - chronological\nconst cutoffDate = new Date('2025-06-15T00:00:00Z');\nconst recentLogins = persons.find({ lastLogin: { $gt: cutoffDate } });\n</code></pre> <p>String Comparisons:</p> <p>Strings are compared lexicographically (alphabetically):</p> <pre><code>// String comparison is case-sensitive\nconst namesAfterM = persons.find({ 'name.last': { $gt: 'M' } });\n// Returns: 'Miller', 'Prince', 'Smith'\n</code></pre>"},{"location":"Querying/#gte-greater-than-or-equal","title":"$gte - Greater Than or Equal","text":"<p>Matches documents where a field value is greater than or equal to the specified value.</p> <pre><code>// Include boundary value\nconst adults = persons.find({ age: { $gte: 18 } });\n\n// Date ranges - inclusive start\nconst startDate = new Date('2025-06-15T00:00:00Z');\nconst fromDate = persons.find({ lastLogin: { $gte: startDate } });\n</code></pre>"},{"location":"Querying/#lt-less-than","title":"$lt - Less Than","text":"<p>Matches documents where a field value is less than the specified value.</p> <pre><code>// Numeric comparisons\nconst youngPersons = persons.find({ age: { $lt: 30 } });\n\n// Float comparisons\nconst lowScores = persons.find({ score: { $lt: 50.0 } });\n\n// Negative numbers\nconst debtBalance = persons.find({ balance: { $lt: 0 } });\n\n// Date comparisons\nconst beforeDate = new Date('2025-06-20T00:00:00Z');\nconst olderLogins = persons.find({ lastLogin: { $lt: beforeDate } });\n</code></pre>"},{"location":"Querying/#lte-less-than-or-equal","title":"$lte - Less Than or Equal","text":"<p>Matches documents where a field value is less than or equal to the specified value.</p> <pre><code>// Include boundary value\nconst maxAge = persons.find({ age: { $lte: 65 } });\n\n// Date ranges - inclusive end\nconst endDate = new Date('2025-06-25T23:59:59Z');\nconst untilDate = persons.find({ lastLogin: { $lte: endDate } });\n\n// Combining with $gte for ranges\nconst ageRange = persons.find({\n  $and: [{ age: { $gte: 30 } }, { age: { $lte: 50 } }]\n});\n</code></pre>"},{"location":"Querying/#ne-not-equal","title":"$ne - Not Equal","text":"<p>Matches documents where a field does not equal the specified value, including documents where the field does not exist.</p> <pre><code>// Not equal to value\nconst notAnna = persons.find({ 'name.first': { $ne: 'Anna' } });\n\n// Exclude null\nconst hasLogin = persons.find({ lastLogin: { $ne: null } });\n\n// Exclude false\nconst notInactive = persons.find({ isActive: { $ne: false } });\n\n// Exclude zero\nconst nonZeroAge = persons.find({ age: { $ne: 0 } });\n</code></pre>"},{"location":"Querying/#in-match-any-value-in-array","title":"$in - Match Any Value in Array","text":"<p>Matches documents where a field value equals any value in the specified array.</p> <pre><code>// String values\nconst specificNames = persons.find({\n  'name.first': { $in: ['Anna', 'Clara', 'Frank'] }\n});\n\n// Numeric values\nconst specificAges = persons.find({ age: { $in: [29, 38, 45] } });\n\n// Mixed types (use with caution)\nconst mixedValues = persons.find({ age: { $in: [0, null, false] } });\n\n// Empty array matches nothing\nconst noMatch = persons.find({ age: { $in: [] } });\n</code></pre>"},{"location":"Querying/#nin-match-no-values-in-array","title":"$nin - Match No Values in Array","text":"<p>Matches documents where a field value does not equal any value in the specified array, including documents where the field does not exist.</p> <pre><code>// Exclude multiple names\nconst excludeNames = persons.find({\n  'name.first': { $nin: ['Ben', 'Ethan'] }\n});\n\n// Exclude multiple numeric values\nconst excludeAges = persons.find({ age: { $nin: [0, 29, 65] } });\n\n// Empty array matches all documents\nconst allMatch = persons.find({ age: { $nin: [] } });\n</code></pre>"},{"location":"Querying/#logical-operators","title":"Logical Operators","text":"<p>Logical operators combine multiple query conditions.</p>"},{"location":"Querying/#and-logical-and","title":"$and - Logical AND","text":"<p>Matches documents that satisfy all specified conditions. Can be expressed implicitly or explicitly.</p> <pre><code>// Implicit AND - most common\nconst result1 = persons.find({\n  isActive: true,\n  age: { $gt: 30 }\n});\n\n// Explicit $and\nconst result2 = persons.find({\n  $and: [{ isActive: { $eq: true } }, { age: { $gt: 30 } }]\n});\n\n// Multiple conditions\nconst result3 = persons.find({\n  $and: [{ isActive: { $eq: true } }, { score: { $gt: 80 } }, { balance: { $gt: 1000 } }]\n});\n\n// Mixed comparison operators\nconst result4 = persons.find({\n  $and: [{ 'name.first': { $eq: 'Anna' } }, { age: { $lt: 35 } }, { score: { $gt: 80 } }]\n});\n</code></pre> <p>Nested $and Operations:</p> <pre><code>const complex = persons.find({\n  $and: [\n    {\n      $and: [{ isActive: { $eq: true } }, { age: { $gt: 25 } }]\n    },\n    { score: { $gt: 85 } }\n  ]\n});\n</code></pre>"},{"location":"Querying/#or-logical-or","title":"$or - Logical OR","text":"<p>Matches documents that satisfy at least one of the specified conditions.</p> <pre><code>// Basic disjunction\nconst youngOrOld = persons.find({\n  $or: [{ age: { $lt: 30 } }, { age: { $gt: 60 } }]\n});\n\n// Multiple conditions\nconst multipleNames = persons.find({\n  $or: [\n    { 'name.first': { $eq: 'Anna' } },\n    { 'name.first': { $eq: 'Clara' } },\n    { 'name.first': { $eq: 'Frank' } }\n  ]\n});\n\n// Mixed comparison operators\nconst mixed = persons.find({\n  $or: [{ score: { $gt: 95 } }, { balance: { $lt: 0 } }, { age: { $eq: 0 } }]\n});\n</code></pre> <p>Nested $or Operations:</p> <pre><code>const nested = persons.find({\n  $or: [\n    {\n      $or: [{ age: { $lt: 30 } }, { age: { $gt: 60 } }]\n    },\n    { score: { $gt: 90 } }\n  ]\n});\n</code></pre>"},{"location":"Querying/#nor-logical-nor","title":"$nor - Logical NOR","text":"<p>Matches documents that fail all specified conditions.</p> <pre><code>// Neither condition is true\nconst result = persons.find({\n  $nor: [{ isActive: { $eq: false } }, { age: { $lt: 30 } }]\n});\n// Returns documents where isActive is true AND age &gt;= 30\n</code></pre>"},{"location":"Querying/#not-logical-not","title":"$not - Logical NOT","text":"<p>Inverts the effect of a query expression.</p> <pre><code>// Not greater than (effectively less than or equal)\nconst notHigh = persons.find({ age: { $not: { $gt: 50 } } });\n\n// Not in range\nconst outsideRange = persons.find({\n  score: { $not: { $gte: 70, $lte: 90 } }\n});\n</code></pre>"},{"location":"Querying/#combining-logical-operators","title":"Combining Logical Operators","text":"<p>Complex queries often require combining multiple logical operators.</p> <p>$and Containing $or Clauses:</p> <pre><code>const result = persons.find({\n  $and: [\n    {\n      $or: [{ 'name.first': { $eq: 'Anna' } }, { 'name.first': { $eq: 'Diana' } }]\n    },\n    { isActive: { $eq: true } }\n  ]\n});\n// Active users named Anna or Diana\n</code></pre> <p>$or Containing $and Clauses:</p> <pre><code>const result = persons.find({\n  $or: [\n    {\n      $and: [{ isActive: { $eq: false } }, { age: { $gt: 40 } }]\n    },\n    { score: { $gt: 95 } }\n  ]\n});\n// Inactive users over 40, or users with score &gt; 95\n</code></pre> <p>Complex Nested Operations:</p> <pre><code>const complex = persons.find({\n  $and: [\n    {\n      $or: [{ age: { $lt: 35 } }, { age: { $gt: 60 } }]\n    },\n    {\n      $or: [{ isActive: { $eq: true } }, { score: { $gt: 90 } }]\n    }\n  ]\n});\n// (Young or old) AND (active or high scorer)\n</code></pre>"},{"location":"Querying/#querying-nested-fields","title":"Querying Nested Fields","text":"<p>JsonDbApp supports querying nested document structures using dot notation or whole-object matching.</p>"},{"location":"Querying/#dot-notation","title":"Dot Notation","text":"<p>Use dot notation to query fields within nested objects:</p> <pre><code>// Query nested string field\nconst anna = persons.findOne({ 'name.first': 'Anna' });\n\n// Query nested numeric field\nconst specificScore = persons.find({ 'metadata.version': { $eq: 1 } });\n\n// Query nested boolean\nconst newsletter = persons.find({ 'preferences.newsletter': true });\n\n// Query nested array\nconst withPhone = persons.find({ 'contact.phones': { $ne: [] } });\n</code></pre>"},{"location":"Querying/#nested-object-equality","title":"Nested Object Equality","text":"<p>Match entire nested objects by providing the complete object structure:</p> <pre><code>// Exact object match\nconst result = persons.find({\n  name: { $eq: { first: 'Anna', last: 'Brown' } }\n});\n\n// Field order matters for object equality\nconst noMatch = persons.find({\n  name: { $eq: { last: 'Brown', first: 'Anna' } } // Won't match\n});\n</code></pre>"},{"location":"Querying/#deep-nesting","title":"Deep Nesting","text":"<p>Dot notation works at any nesting level:</p> <pre><code>// Deep nested field access\nconst weeklyEmail = persons.find({\n  'preferences.settings.notifications.email.frequency': 'weekly'\n});\n\n// Multiple deep nested conditions\nconst complexNested = persons.find({\n  'preferences.settings.notifications.email.enabled': true,\n  'preferences.settings.notifications.email.frequency': { $ne: 'immediate' }\n});\n</code></pre>"},{"location":"Querying/#array-queries","title":"Array Queries","text":"<p>Query documents based on array field contents.</p>"},{"location":"Querying/#matching-array-values","title":"Matching Array Values","text":"<pre><code>// Array contains value\nconst withTag = persons.find({ 'preferences.tags': 'sports' });\n\n// Array contains any of multiple values\nconst withTags = persons.find({\n  'preferences.tags': { $in: ['music', 'travel'] }\n});\n\n// All values must be present (use $all if supported)\n// Note: $all may not be implemented - check documentation\n</code></pre>"},{"location":"Querying/#empty-arrays","title":"Empty Arrays","text":"<pre><code>// Match empty array\nconst emptyPhones = persons.find({ 'contact.phones': [] });\n\n// Match non-empty array using $ne\nconst hasPhones = persons.find({ 'contact.phones': { $ne: [] } });\n\n// Match empty array explicitly with $eq\nconst noPhones = persons.find({ 'contact.phones': { $eq: [] } });\n</code></pre>"},{"location":"Querying/#array-length","title":"Array Length","text":"<p>Array length queries may require combining with custom logic:</p> <pre><code>// Find documents where array has specific length\n// This requires application logic as $size may not be implemented\nconst docs = persons.find({ 'contact.phones': { $exists: true } });\nconst multiplePhones = docs.filter((doc) =&gt; doc.contact.phones.length &gt; 1);\n</code></pre>"},{"location":"Querying/#edge-cases-and-special-values","title":"Edge Cases and Special Values","text":""},{"location":"Querying/#null-values","title":"Null Values","text":"<pre><code>// Match null explicitly\nconst nullEmail = persons.find({ 'contact.email': { $eq: null } });\n\n// Exclude null\nconst hasEmail = persons.find({ 'contact.email': { $ne: null } });\n\n// Null vs undefined\n// Missing fields are treated as undefined, not null\nconst missingField = persons.find({ nonExistent: { $eq: null } });\n// This may or may not match depending on implementation\n</code></pre>"},{"location":"Querying/#zero-and-false","title":"Zero and False","text":"<pre><code>// Zero is distinct from false\nconst ageZero = persons.find({ age: 0 });\nconst ageFalse = persons.find({ age: false }); // Won't match age: 0\n\n// Explicit distinction\nconst zeroAge = persons.find({ age: { $eq: 0 } });\nconst falseActive = persons.find({ isActive: { $eq: false } });\n\n// Both zero and false are falsy, but not equal\nconst notZero = persons.find({ age: { $ne: 0 } }); // Includes false, null, etc.\n</code></pre>"},{"location":"Querying/#empty-strings","title":"Empty Strings","text":"<pre><code>// Empty string is distinct from null\nconst emptyEmail = persons.find({ 'contact.email': '' });\nconst nullEmail = persons.find({ 'contact.email': null });\n\n// Exclude both empty and null\nconst validEmail = persons.find({\n  $and: [{ 'contact.email': { $ne: '' } }, { 'contact.email': { $ne: null } }]\n});\n</code></pre>"},{"location":"Querying/#missing-fields","title":"Missing Fields","text":"<pre><code>// Query for non-existent fields\n// Behaviour depends on operator\n\n// $eq: null may match missing fields\nconst result1 = persons.find({ nonExistent: { $eq: null } });\n\n// $ne: value matches missing fields\nconst result2 = persons.find({ nonExistent: { $ne: 'value' } });\n\n// Use $exists if implemented\n// const hasField = persons.find({ field: { $exists: true } });\n</code></pre>"},{"location":"Querying/#query-performance-tips","title":"Query Performance Tips","text":"<ol> <li>Use Specific Queries: More specific queries reduce the number of documents scanned:</li> </ol> <pre><code>// Better\nconst result = persons.find({ _id: 'person1' });\n\n// Less efficient\nconst result = persons.find({ 'name.first': 'Anna' });\n</code></pre> <ol> <li>Combine Filters Efficiently: Place most restrictive conditions first in implicit AND queries:</li> </ol> <pre><code>// More efficient (fewer documents pass first filter)\nconst result = persons.find({\n  isActive: true,\n  age: { $gt: 30 },\n  score: { $gt: 80 }\n});\n</code></pre> <ol> <li>Avoid Redundant Operators: Use implicit equality when possible:</li> </ol> <pre><code>// Simpler\nconst result = persons.find({ isActive: true });\n\n// Unnecessary explicit $eq\nconst result = persons.find({ isActive: { $eq: true } });\n</code></pre> <ol> <li>Limit Result Sets: Use query specificity to reduce result set size before application-level filtering.</li> </ol>"},{"location":"Querying/#complete-examples","title":"Complete Examples","text":"<p>Find Active Adults with High Scores:</p> <pre><code>const eliteUsers = persons.find({\n  isActive: true,\n  age: { $gte: 18 },\n  score: { $gt: 85 }\n});\n</code></pre> <p>Find Users Who Recently Logged In:</p> <pre><code>const cutoffDate = new Date('2025-06-20T00:00:00Z');\nconst recentUsers = persons.find({\n  lastLogin: { $gte: cutoffDate },\n  isActive: true\n});\n</code></pre> <p>Complex Nested Query:</p> <pre><code>const premiumUsers = persons.find({\n  $and: [\n    { balance: { $gt: 1000 } },\n    { 'preferences.newsletter': true },\n    { 'preferences.settings.notifications.email.enabled': true },\n    {\n      $or: [{ 'preferences.settings.theme': 'dark' }, { 'preferences.settings.theme': 'auto' }]\n    }\n  ]\n});\n</code></pre> <p>Multi-Condition Search:</p> <pre><code>const targetUsers = persons.find({\n  $or: [\n    {\n      $and: [{ isActive: true }, { age: { $lt: 30 } }, { score: { $gt: 80 } }]\n    },\n    {\n      $and: [{ isActive: false }, { balance: { $gt: 5000 } }]\n    }\n  ]\n});\n</code></pre> <p>For more examples, see Examples.md. For update operations, see Updates.md. For technical details, see developers/QueryEngine.md.</p>"},{"location":"Quick_Start/","title":"Quick Start Guide","text":"<ul> <li>Quick Start Guide</li> <li>Overview</li> <li>Prerequisites</li> <li>Create or Load a Database</li> <li>Create a Collection and Insert Data</li> <li>Read, Update, and Delete</li> <li>Persist Changes</li> </ul>"},{"location":"Quick_Start/#overview","title":"Overview","text":"<p>This guide walks through creating a database, adding data, and running basic queries using the public JsonDbApp API. It targets Apps Script library consumers and mirrors the MongoDB-style collection interface.</p>"},{"location":"Quick_Start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Google Apps Script project with the JsonDbApp library added.</li> <li>Drive API enabled for the Google Cloud project that backs your Apps Script deployment.</li> </ul>"},{"location":"Quick_Start/#create-or-load-a-database","title":"Create or Load a Database","text":"<p>Use the public wrappers exposed by the library identifier (typically <code>JsonDbApp</code>). For first-time setup, create and initialise the MasterIndex. For subsequent use, load the existing database.</p> <pre><code>const config = new DatabaseConfig({\n  rootFolderId: 'YOUR_DRIVE_FOLDER_ID',\n  autoCreateCollections: true\n});\n\n// First-time setup\nconst db = JsonDbApp.createAndInitialiseDatabase(config);\n\n// Existing database\n// const db = JsonDbApp.loadDatabase(config);\n</code></pre>"},{"location":"Quick_Start/#create-a-collection-and-insert-data","title":"Create a Collection and Insert Data","text":"<pre><code>const users = db.createCollection('users');\n\nconst result = users.insertOne({\n  name: 'Ada',\n  role: 'Engineer',\n  age: 36\n});\n\nconst userId = result.insertedId;\n</code></pre>"},{"location":"Quick_Start/#read-update-and-delete","title":"Read, Update, and Delete","text":"<pre><code>// Read\nconst ada = users.findOne({ _id: userId });\nconst engineers = users.find({ role: 'Engineer' });\n\n// Update\nusers.updateOne({ _id: userId }, { $set: { role: 'Lead Engineer' } });\n\n// Delete\nusers.deleteOne({ _id: userId });\n</code></pre>"},{"location":"Quick_Start/#persist-changes","title":"Persist Changes","text":"<p>Write operations mark collections as dirty. Call <code>save()</code> after a batch of changes so data is written to Drive.</p> <pre><code>users.save();\n</code></pre>"},{"location":"Updates/","title":"Update Operations","text":"<ul> <li>Update Operations</li> <li>Overview</li> <li>Basic Update Syntax</li> <li>Field Update Operators<ul> <li>$set - Set Field Value</li> <li>$unset - Remove Field</li> <li>$inc - Increment Numeric Value</li> <li>$mul - Multiply Numeric Value</li> <li>$min - Set Minimum Value</li> <li>$max - Set Maximum Value</li> <li>$rename - Rename Field</li> </ul> </li> <li>Array Update Operators<ul> <li>$push - Append to Array</li> <li>$pull - Remove from Array</li> <li>$addToSet - Add Unique to Array</li> <li>$pop - Remove First or Last Element</li> </ul> </li> <li>Update Patterns<ul> <li>Creating Nested Structures</li> <li>Type Changes</li> <li>Partial Object Updates</li> <li>Multiple Field Updates</li> </ul> </li> <li>Edge Cases and Validation<ul> <li>The _id Field</li> <li>Non-Existent Fields</li> <li>Type Mismatches</li> <li>Empty Values</li> </ul> </li> <li>Update Methods<ul> <li>updateOne(filter, update)</li> <li>updateMany(filter, update)</li> <li>replaceOne(filter, replacement)</li> </ul> </li> <li>Complete Examples</li> </ul>"},{"location":"Updates/#overview","title":"Overview","text":"<p>JsonDbApp provides MongoDB-compatible update operators for modifying documents in collections. Updates are expressed using operator syntax where operator names (prefixed with <code>$</code>) map to update actions. This guide covers all supported update operators with practical examples.</p>"},{"location":"Updates/#basic-update-syntax","title":"Basic Update Syntax","text":"<p>Updates are performed using <code>updateOne()</code>, <code>updateMany()</code>, or <code>replaceOne()</code> methods:</p> <pre><code>const users = db.getCollection('users');\n\n// Update single document\nusers.updateOne({ _id: 'user123' }, { $set: { status: 'active' } });\n\n// Update multiple documents\nusers.updateMany({ status: 'pending' }, { $set: { reviewed: true } });\n\n// Replace entire document (except _id)\nusers.replaceOne({ _id: 'user123' }, { _id: 'user123', name: 'New Name', role: 'admin' });\n\n// Persist changes to Drive\nusers.save();\n</code></pre>"},{"location":"Updates/#field-update-operators","title":"Field Update Operators","text":"<p>Field operators modify specific fields within documents.</p>"},{"location":"Updates/#set-set-field-value","title":"$set - Set Field Value","text":"<p>Sets the value of a field. If the field does not exist, <code>$set</code> creates it. Works with all data types and supports dot notation for nested fields.</p> <p>Overwriting Existing Values:</p> <pre><code>const persons = db.getCollection('persons');\n\n// String values\npersons.updateOne({ _id: 'person1' }, { $set: { 'name.first': 'Alexandra' } });\n\n// Numeric values\npersons.updateOne({ _id: 'person1' }, { $set: { age: 35, score: 92.7 } });\n\n// Boolean values\npersons.updateOne({ _id: 'person1' }, { $set: { isActive: false } });\n\n// Array values\npersons.updateOne({ _id: 'person1' }, { $set: { 'preferences.tags': ['updated', 'test'] } });\n\n// Object values\nconst newContact = { email: 'new@example.com', phones: ['999-111-2222'] };\npersons.updateOne({ _id: 'person1' }, { $set: { contact: newContact } });\n</code></pre> <p>Creating New Fields:</p> <pre><code>// Create top-level fields\npersons.updateOne({ _id: 'person1' }, { $set: { newField: 'new value', anotherField: 42 } });\n\n// Create nested fields using dot notation\npersons.updateOne({ _id: 'person1' }, { $set: { 'preferences.settings.theme': 'auto' } });\n\n// Create deeply nested fields (intermediate objects created automatically)\npersons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $set: { 'preferences.settings.notifications.push.enabled': true }\n  }\n);\n</code></pre> <p>Type Changes:</p> <pre><code>// String to number\npersons.updateOne({ _id: 'person1' }, { $set: { age: 30 } }); // Was string, now number\n\n// Number to array\npersons.updateOne({ _id: 'person1' }, { $set: { score: [85, 90, 95] } });\n\n// Object to primitive\npersons.updateOne({ _id: 'person1' }, { $set: { contact: 'email@example.com' } });\n\n// Null to non-null\npersons.updateOne({ _id: 'person1' }, { $set: { lastLogin: new Date() } });\n</code></pre>"},{"location":"Updates/#unset-remove-field","title":"$unset - Remove Field","text":"<p>Removes the specified field from a document. The value provided to <code>$unset</code> is ignored\u2014any value works (typically empty string <code>''</code> or <code>1</code>).</p> <p>Basic Field Removal:</p> <pre><code>// Remove single top-level field\npersons.updateOne({ _id: 'person1' }, { $unset: { tempField: '' } });\n\n// Remove multiple fields\npersons.updateOne({ _id: 'person1' }, { $unset: { temp1: '', temp3: '' } });\n\n// Remove nested field using dot notation\npersons.updateOne({ _id: 'person1' }, { $unset: { 'preferences.newsletter': '' } });\n\n// Remove deeply nested field\npersons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $unset: { 'preferences.settings.notifications.email.frequency': '' }\n  }\n);\n</code></pre> <p>Object Structure Preservation:</p> <pre><code>// Parent object remains after removing field\npersons.updateOne({ _id: 'person1' }, { $unset: { 'name.first': '' } });\n// document.name still exists as { last: 'Brown' }\n\n// Removing all fields leaves empty object\npersons.updateOne({ _id: 'person1' }, { $unset: { 'name.first': '', 'name.last': '' } });\n// document.name now equals {}\n\n// Object hierarchy maintained\npersons.updateOne({ _id: 'person1' }, { $unset: { 'preferences.settings.theme': '' } });\n// document.preferences and document.preferences.settings still exist\n</code></pre> <p>Edge Cases:</p> <pre><code>// Removing non-existent field is a no-op\nconst result = persons.updateOne({ _id: 'person1' }, { $unset: { nonExistent: '' } });\nconsole.log(result.modifiedCount); // 0\n\n// Cannot remove _id field\n// Attempting to unset _id may throw error or be ignored\n</code></pre>"},{"location":"Updates/#inc-increment-numeric-value","title":"$inc - Increment Numeric Value","text":"<p>Increments a numeric field by a specified amount. If the field does not exist, it is created with the increment value. Accepts positive or negative numbers.</p> <p>Basic Incrementation:</p> <pre><code>// Increment positive integer\npersons.updateOne({ _id: 'person1' }, { $inc: { age: 5 } });\n\n// Increment decimal\npersons.updateOne({ _id: 'person1' }, { $inc: { score: 10.5 } });\n\n// Decrement with negative value\npersons.updateOne({ _id: 'person4' }, { $inc: { age: -3, score: -8.1 } });\n\n// Zero increment is no-op\nconst result = persons.updateOne({ _id: 'person3' }, { $inc: { age: 0 } });\nconsole.log(result.modifiedCount); // 0 (no change)\n</code></pre> <p>Field Creation:</p> <pre><code>// Create field with increment value if it does not exist\npersons.updateOne({ _id: 'person2' }, { $inc: { newCounter: 100 } });\n// document.newCounter now equals 100\n\n// Create nested field\npersons.updateOne({ _id: 'person2' }, { $inc: { 'stats.loginCount': 1 } });\n// document.stats.loginCount created with value 1\n</code></pre> <p>Type Validation:</p> <pre><code>// Incrementing non-numeric field throws error\ntry {\n  persons.updateOne({ _id: 'person1' }, { $inc: { 'name.first': 1 } });\n} catch (error) {\n  console.log('Cannot increment non-numeric field');\n}\n\n// Non-numeric increment value throws error\ntry {\n  persons.updateOne({ _id: 'person1' }, { $inc: { age: 'five' } });\n} catch (error) {\n  console.log('Increment value must be numeric');\n}\n</code></pre> <p>Boundary Cases:</p> <pre><code>// Large numbers\npersons.updateOne({ _id: 'person1' }, { $inc: { balance: 1000000 } });\n\n// Floating point precision\npersons.updateOne({ _id: 'person1' }, { $inc: { score: 0.1 } });\n// Be aware of floating point arithmetic limitations\n\n// Maximum safe integer (Number.MAX_SAFE_INTEGER = 9007199254740991)\n// Exceeding this may cause precision issues\n</code></pre>"},{"location":"Updates/#mul-multiply-numeric-value","title":"$mul - Multiply Numeric Value","text":"<p>Multiplies a numeric field by a specified value. If the field does not exist, it is created with value <code>0</code>.</p> <p>Basic Multiplication:</p> <pre><code>// Multiply by positive number\npersons.updateOne({ _id: 'person1' }, { $mul: { score: 1.1 } });\n\n// Multiply by fraction\npersons.updateOne({ _id: 'person1' }, { $mul: { balance: 0.9 } });\n\n// Multiply by zero (sets field to 0)\npersons.updateOne({ _id: 'person1' }, { $mul: { age: 0 } });\n\n// Multiply by negative (inverts sign)\npersons.updateOne({ _id: 'person3' }, { $mul: { balance: -1 } });\n</code></pre> <p>Field Creation:</p> <pre><code>// Non-existent field created as 0\nconst result = persons.updateOne({ _id: 'person2' }, { $mul: { newField: 5 } });\n// document.newField now equals 0 (0 * 5)\n</code></pre>"},{"location":"Updates/#min-set-minimum-value","title":"$min - Set Minimum Value","text":"<p>Updates field value only if the specified value is less than the current field value. If the field does not exist, sets the field to the specified value.</p> <p>Basic Usage:</p> <pre><code>// Update if new value is smaller\npersons.updateOne({ _id: 'person1' }, { $min: { age: 25 } });\n// If age was 29, now 25; if age was 20, still 20\n\n// Works with decimals\npersons.updateOne({ _id: 'person1' }, { $min: { score: 80.0 } });\n\n// Works with negative numbers\npersons.updateOne({ _id: 'person1' }, { $min: { balance: -100 } });\n\n// Works with dates\nconst minDate = new Date('2025-01-01T00:00:00Z');\npersons.updateOne({ _id: 'person1' }, { $min: { lastLogin: minDate } });\n</code></pre> <p>Field Creation:</p> <pre><code>// Creates field if it does not exist\npersons.updateOne({ _id: 'person2' }, { $min: { newMin: 50 } });\n// document.newMin now equals 50\n</code></pre>"},{"location":"Updates/#max-set-maximum-value","title":"$max - Set Maximum Value","text":"<p>Updates field value only if the specified value is greater than the current field value. If the field does not exist, sets the field to the specified value.</p> <p>Basic Usage:</p> <pre><code>// Update if new value is larger\npersons.updateOne({ _id: 'person1' }, { $max: { age: 40 } });\n// If age was 29, now 40; if age was 50, still 50\n\n// Works with decimals\npersons.updateOne({ _id: 'person1' }, { $max: { score: 95.0 } });\n\n// Works with negative numbers\npersons.updateOne({ _id: 'person3' }, { $max: { balance: 0 } });\n\n// Works with dates\nconst maxDate = new Date('2025-12-31T23:59:59Z');\npersons.updateOne({ _id: 'person1' }, { $max: { lastLogin: maxDate } });\n</code></pre>"},{"location":"Updates/#rename-rename-field","title":"$rename - Rename Field","text":"<p>Renames a field. If the new field name already exists, it is overwritten. If the old field does not exist, no operation is performed.</p> <p>Basic Usage:</p> <pre><code>// Rename top-level field\npersons.updateOne({ _id: 'person1' }, { $rename: { oldName: 'newName' } });\n\n// Rename nested field\npersons.updateOne({ _id: 'person1' }, { $rename: { 'name.first': 'name.firstName' } });\n\n// Rename with overwrite\npersons.updateOne({ _id: 'person1' }, { $rename: { tempValue: 'age' } });\n// If 'age' exists, it is overwritten with 'tempValue'\n</code></pre>"},{"location":"Updates/#array-update-operators","title":"Array Update Operators","text":"<p>Array operators modify array fields within documents.</p>"},{"location":"Updates/#push-append-to-array","title":"$push - Append to Array","text":"<p>Appends a value to an array field. If the field does not exist, creates a new array with the value. If the field exists but is not an array, throws an error.</p> <p>Basic Appending:</p> <pre><code>// Append single value\npersons.updateOne({ _id: 'person1' }, { $push: { 'preferences.tags': 'new-tag' } });\n// tags: ['sports', 'music', 'new-tag']\n\n// Append object\nconst inventory = db.getCollection('inventory');\nconst newAlert = { type: 'high-temp', value: 30 };\ninventory.updateOne({ _id: 'inv1' }, { $push: { alerts: newAlert } });\n</code></pre> <p>Array Creation:</p> <pre><code>// Create array when field does not exist\npersons.updateOne({ _id: 'person2' }, { $push: { newArrayField: 'first-element' } });\n// document.newArrayField now equals ['first-element']\n\n// Create nested array\npersons.updateOne({ _id: 'person2' }, { $push: { 'newly.nested.array': 'value' } });\n// Intermediate objects created automatically\n</code></pre> <p>$each Modifier:</p> <pre><code>// Push multiple values at once\npersons.updateOne(\n  {\n    _id: 'person4'\n  },\n  {\n    $push: { 'preferences.tags': { $each: ['new1', 'new2', 'new3'] } }\n  }\n);\n// tags: ['travel', 'photography', 'music', 'new1', 'new2', 'new3']\n\n// Empty $each array is no-op\nconst result = persons.updateOne(\n  {\n    _id: 'person5'\n  },\n  {\n    $push: { 'preferences.tags': { $each: [] } }\n  }\n);\nconsole.log(result.modifiedCount); // 0\n\n// Push array of objects\nconst newAlerts = [\n  { type: 'temp', level: 'warning' },\n  { type: 'pressure', level: 'critical' }\n];\ninventory.updateOne({ _id: 'inv1' }, { $push: { alerts: { $each: newAlerts } } });\n</code></pre> <p>Type Validation:</p> <pre><code>// Pushing to non-array field throws error\ntry {\n  persons.updateOne({ _id: 'person1' }, { $push: { 'name.first': 'invalid' } });\n} catch (error) {\n  console.log('Cannot push to non-array field');\n}\n</code></pre>"},{"location":"Updates/#pull-remove-from-array","title":"$pull - Remove from Array","text":"<p>Removes all elements from an array that match the specified condition. Can remove by value or by query operator.</p> <p>Basic Value Removal:</p> <pre><code>// Remove specific value\npersons.updateOne({ _id: 'person3' }, { $pull: { 'preferences.tags': 'alerts' } });\n// tags: ['news', 'sports'] (removed 'alerts')\n\n// Remove all occurrences\nconst orders = db.getCollection('orders');\norders.updateOne({ _id: 'order3' }, { $pull: { items: { sku: 'prod1' } } });\n// Removes all items where sku equals 'prod1'\n</code></pre> <p>Edge Cases:</p> <pre><code>// Pulling from non-array field is gracefully ignored\nconst result = persons.updateOne({ _id: 'person1' }, { $pull: { 'name.first': 'Anna' } });\nconsole.log(result.modifiedCount); // 0\n\n// Pulling non-existent value is no-op\nconst result2 = persons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $pull: { 'preferences.tags': 'non-existent' }\n  }\n);\nconsole.log(result2.modifiedCount); // 0\n\n// Pulling from empty array is no-op\nconst result3 = persons.updateOne({ _id: 'person2' }, { $pull: { 'contact.phones': '123' } });\nconsole.log(result3.modifiedCount); // 0\n</code></pre> <p>Operator Predicates:</p> <pre><code>// Remove with comparison operator\norders.updateOne({ _id: 'order1' }, { $pull: { 'items.quantity': { $lt: 5 } } });\n\n// Remove with multiple conditions\ninventory.updateOne(\n  {\n    _id: 'inv1'\n  },\n  {\n    $pull: { alerts: { type: 'low-stock', level: { $ne: 'critical' } } }\n  }\n);\n</code></pre>"},{"location":"Updates/#addtoset-add-unique-to-array","title":"$addToSet - Add Unique to Array","text":"<p>Adds a value to an array only if it does not already exist in the array. Ensures array elements remain unique.</p> <p>Adding Unique Values:</p> <pre><code>// Add unique primitive value\npersons.updateOne({ _id: 'person1' }, { $addToSet: { 'preferences.tags': 'new-tag' } });\n// Added only if 'new-tag' not already present\n\n// Add unique object\nconst inventory = db.getCollection('inventory');\nconst alert = { type: 'security-alert', level: 'high' };\ninventory.updateOne({ _id: 'inv1' }, { $addToSet: { alerts: alert } });\n</code></pre> <p>Duplicate Prevention:</p> <pre><code>// No-op if value already exists\nconst result = persons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $addToSet: { 'preferences.tags': 'sports' }\n  }\n);\nconsole.log(result.modifiedCount); // 0 (already exists)\n\n// Object equality checked by value\nconst existingAlert = { type: 'low-stock', product: 'prod3', threshold: 10 };\nconst result2 = inventory.updateOne({ _id: 'inv1' }, { $addToSet: { alerts: existingAlert } });\nconsole.log(result2.modifiedCount); // 0 if exact object exists\n</code></pre> <p>$each Modifier:</p> <pre><code>// Add multiple unique values\npersons.updateOne(\n  {\n    _id: 'person4'\n  },\n  {\n    $addToSet: { 'preferences.tags': { $each: ['tag1', 'tag2', 'tag3'] } }\n  }\n);\n// Only non-duplicate tags added\n\n// Combining new and existing values\npersons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $addToSet: { 'preferences.tags': { $each: ['sports', 'new1', 'music', 'new2'] } }\n  }\n);\n// Only 'new1' and 'new2' added (sports and music already exist)\n</code></pre> <p>Array Creation:</p> <pre><code>// Create array if field does not exist\npersons.updateOne({ _id: 'person2' }, { $addToSet: { newSetField: 'first-unique' } });\n// document.newSetField now equals ['first-unique']\n</code></pre>"},{"location":"Updates/#pop-remove-first-or-last-element","title":"$pop - Remove First or Last Element","text":"<p>Removes the first or last element from an array. Use value <code>1</code> to remove the last element, <code>-1</code> to remove the first.</p> <p>Basic Usage:</p> <pre><code>// Remove last element\npersons.updateOne({ _id: 'person3' }, { $pop: { 'preferences.tags': 1 } });\n\n// Remove first element\npersons.updateOne({ _id: 'person4' }, { $pop: { 'contact.phones': -1 } });\n\n// Empty array results in no-op\nconst result = persons.updateOne({ _id: 'person2' }, { $pop: { 'contact.phones': 1 } });\nconsole.log(result.modifiedCount); // 0\n</code></pre>"},{"location":"Updates/#update-patterns","title":"Update Patterns","text":""},{"location":"Updates/#creating-nested-structures","title":"Creating Nested Structures","text":"<p><code>$set</code> automatically creates intermediate objects when using dot notation:</p> <pre><code>// Create entire nested structure\npersons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $set: {\n      'newly.created.nested.field': 'value',\n      'newly.created.sibling': 'another value'\n    }\n  }\n);\n// Creates: { newly: { created: { nested: { field: 'value' }, sibling: 'another value' } } }\n\n// Mixing existing and new nested paths\npersons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $set: {\n      'preferences.settings.newSetting': true,\n      'preferences.newTopLevel': 'value'\n    }\n  }\n);\n</code></pre>"},{"location":"Updates/#type-changes","title":"Type Changes","text":"<p>Update operators can change field types:</p> <pre><code>// String to number\npersons.updateOne({ _id: 'person1' }, { $set: { age: '30' } }); // String\npersons.updateOne({ _id: 'person1' }, { $set: { age: 30 } }); // Now number\n\n// Scalar to array\npersons.updateOne({ _id: 'person1' }, { $set: { score: 85 } }); // Number\npersons.updateOne({ _id: 'person1' }, { $set: { score: [85, 90, 95] } }); // Now array\n\n// Object to scalar\npersons.updateOne({ _id: 'person1' }, { $set: { contact: { email: 'test@example.com' } } });\npersons.updateOne({ _id: 'person1' }, { $set: { contact: 'simple string' } });\n</code></pre>"},{"location":"Updates/#partial-object-updates","title":"Partial Object Updates","text":"<p>Use dot notation to update specific fields within objects without replacing the entire object:</p> <pre><code>// Update one field, preserve others\npersons.updateOne({ _id: 'person1' }, { $set: { 'name.first': 'Anna' } });\n// document.name.last remains unchanged\n\n// Update multiple nested fields\npersons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $set: {\n      'preferences.newsletter': false,\n      'preferences.settings.theme': 'dark'\n    }\n  }\n);\n// Other preferences fields remain unchanged\n</code></pre>"},{"location":"Updates/#multiple-field-updates","title":"Multiple Field Updates","text":"<p>Combine multiple operators in a single update:</p> <pre><code>// Multiple $set operations\npersons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $set: {\n      'name.first': 'Anna',\n      age: 30,\n      isActive: true\n    }\n  }\n);\n\n// Combine different operators\npersons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $set: { status: 'active' },\n    $inc: { loginCount: 1 },\n    $push: { 'activity.logins': new Date() },\n    $unset: { tempFlag: '' }\n  }\n);\n</code></pre>"},{"location":"Updates/#edge-cases-and-validation","title":"Edge Cases and Validation","text":""},{"location":"Updates/#the-_id-field","title":"The _id Field","text":"<p>The <code>_id</code> field is immutable and cannot be updated:</p> <pre><code>// Attempting to update _id may throw error or be ignored\ntry {\n  persons.updateOne({ _id: 'person1' }, { $set: { _id: 'newId' } });\n} catch (error) {\n  console.log('Cannot modify _id field');\n}\n\n// $unset on _id may also fail\ntry {\n  persons.updateOne({ _id: 'person1' }, { $unset: { _id: '' } });\n} catch (error) {\n  console.log('Cannot remove _id field');\n}\n</code></pre>"},{"location":"Updates/#non-existent-fields","title":"Non-Existent Fields","text":"<p>Most operators handle non-existent fields gracefully:</p> <pre><code>// $set creates field\npersons.updateOne({ _id: 'person1' }, { $set: { newField: 'value' } });\n\n// $inc creates field with increment value\npersons.updateOne({ _id: 'person1' }, { $inc: { counter: 1 } });\n\n// $mul creates field as 0\npersons.updateOne({ _id: 'person1' }, { $mul: { multiplier: 5 } });\n// Field created with value 0\n\n// $min/$max create field with specified value\npersons.updateOne({ _id: 'person1' }, { $min: { minValue: 100 } });\n\n// $unset on non-existent field is no-op\nconst result = persons.updateOne({ _id: 'person1' }, { $unset: { nonExistent: '' } });\nconsole.log(result.modifiedCount); // 0\n</code></pre>"},{"location":"Updates/#type-mismatches","title":"Type Mismatches","text":"<p>Type mismatches generally throw errors:</p> <pre><code>// $inc on non-numeric field\ntry {\n  persons.updateOne({ _id: 'person1' }, { $inc: { 'name.first': 1 } });\n} catch (error) {\n  console.log('Cannot increment non-numeric field');\n}\n\n// $push on non-array field\ntry {\n  persons.updateOne({ _id: 'person1' }, { $push: { age: 'value' } });\n} catch (error) {\n  console.log('Cannot push to non-array field');\n}\n\n// $pull on non-array field may be gracefully ignored\nconst result = persons.updateOne({ _id: 'person1' }, { $pull: { age: 30 } });\nconsole.log(result.modifiedCount); // 0 (no error, no change)\n</code></pre>"},{"location":"Updates/#empty-values","title":"Empty Values","text":"<p>Handling of empty values varies by operator:</p> <pre><code>// $set with null\npersons.updateOne({ _id: 'person1' }, { $set: { lastLogin: null } });\n// Field set to null\n\n// $set with undefined may behave like $unset\npersons.updateOne({ _id: 'person1' }, { $set: { field: undefined } });\n// Check implementation details\n\n// $set with empty string\npersons.updateOne({ _id: 'person1' }, { $set: { 'contact.email': '' } });\n// Field set to empty string (distinct from null)\n\n// $set with empty array\npersons.updateOne({ _id: 'person1' }, { $set: { 'contact.phones': [] } });\n// Field set to empty array\n\n// $set with empty object\npersons.updateOne({ _id: 'person1' }, { $set: { metadata: {} } });\n// Field set to empty object\n</code></pre>"},{"location":"Updates/#update-methods","title":"Update Methods","text":"<p>JsonDbApp provides three primary update methods:</p>"},{"location":"Updates/#updateonefilter-update","title":"updateOne(filter, update)","text":"<p>Updates a single document matching the filter:</p> <pre><code>const result = persons.updateOne({ _id: 'person1' }, { $set: { status: 'active' } });\n\nconsole.log(result.matchedCount); // 1 if document found\nconsole.log(result.modifiedCount); // 1 if document changed\n</code></pre>"},{"location":"Updates/#updatemanyfilter-update","title":"updateMany(filter, update)","text":"<p>Updates all documents matching the filter:</p> <pre><code>const result = persons.updateMany({ isActive: false }, { $set: { reviewed: true } });\n\nconsole.log(result.matchedCount); // Number of documents matched\nconsole.log(result.modifiedCount); // Number of documents changed\n</code></pre>"},{"location":"Updates/#replaceonefilter-replacement","title":"replaceOne(filter, replacement)","text":"<p>Replaces an entire document (except <code>_id</code>):</p> <pre><code>const replacement = {\n  _id: 'person1',\n  name: { first: 'Anna', last: 'Brown' },\n  age: 30,\n  isActive: true\n};\n\nconst result = persons.replaceOne({ _id: 'person1' }, replacement);\n// All fields replaced except _id\n</code></pre>"},{"location":"Updates/#complete-examples","title":"Complete Examples","text":"<p>Increment Login Count and Update Last Login:</p> <pre><code>persons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $inc: { 'stats.loginCount': 1 },\n    $set: { lastLogin: new Date() }\n  }\n);\n</code></pre> <p>Add Tags and Update Preferences:</p> <pre><code>persons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $addToSet: { 'preferences.tags': { $each: ['premium', 'verified'] } },\n    $set: { 'preferences.newsletter': true }\n  }\n);\n</code></pre> <p>Update Nested Settings:</p> <pre><code>persons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $set: {\n      'preferences.settings.theme': 'dark',\n      'preferences.settings.notifications.email.enabled': true,\n      'preferences.settings.notifications.email.frequency': 'daily'\n    }\n  }\n);\n</code></pre> <p>Clean Up Old Fields and Add New Ones:</p> <pre><code>persons.updateOne(\n  {\n    _id: 'person1'\n  },\n  {\n    $unset: { legacyField: '', deprecatedSetting: '' },\n    $set: { newField: 'value', version: 2 }\n  }\n);\n</code></pre> <p>Batch Update with Multiple Operators:</p> <pre><code>persons.updateMany(\n  {\n    isActive: true,\n    lastLogin: { $lt: new Date('2025-01-01') }\n  },\n  {\n    $set: { status: 'stale', reviewRequired: true },\n    $inc: { inactivityScore: 10 },\n    $push: { 'history.events': { type: 'flagged', date: new Date() } }\n  }\n);\n</code></pre> <p>Complex Nested Array Update:</p> <pre><code>const orders = db.getCollection('orders');\n\norders.updateOne(\n  {\n    _id: 'order1'\n  },\n  {\n    $push: { items: { sku: 'prod5', quantity: 3, price: 29.99 } },\n    $inc: { totalAmount: 89.97, 'metrics.itemCount': 3 },\n    $set: { updatedAt: new Date(), status: 'modified' }\n  }\n);\n</code></pre> <p>For query operations, see Querying.md. For more examples, see Examples.md. For technical details, see developers/UpdateEngine.md.</p>"},{"location":"developers/","title":"Developer Documentation","text":"<p>This section contains detailed documentation for developers contributing to or working with the GAS DB project.</p> <p>\u26a0\ufe0f HEALTH WARNING \u26a0\ufe0f</p> <p>These documents have been created by various LLMs and I've only given them a cursory skim for accuracy so they may not be fully updated.</p>"},{"location":"developers/#important-step-to-avoid-weird-issues","title":"Important step to avoid weird issues","text":"<p>Make sure you've enabled the DriveAPI in your Google Cloud project. This is crucial for the JsonDbApp to function correctly, especially for features like MasterIndex and file watching.</p>"},{"location":"developers/#core-documentation","title":"Core Documentation","text":"<ul> <li>Class Diagrams - Updated UML class and sequence diagrams for the JsonDbApp MVP</li> <li>Quick Start Guide - Practical setup steps and basic CRUD walkthrough</li> <li>Detailed Examples - Extended usage patterns for setup, CRUD, and querying</li> </ul>"},{"location":"developers/#public-api-for-apps-script-consumers","title":"Public API (for Apps Script consumers)","text":"<p>Use the top-level library functions instead of constructing classes directly:</p> <ul> <li><code>JsonDbApp.createAndInitialiseDatabase(config)</code> \u2013 first-time setup</li> <li><code>JsonDbApp.loadDatabase(config)</code> \u2013 load existing DB</li> </ul> <p>Within this repo (<code>old_tests/</code>), you can still use <code>new Database(config)</code> then call <code>createDatabase()</code>/<code>initialise()</code> explicitly.</p> <ul> <li>Collection Components - Detailed explanation of Collection, CollectionMetadata, and DocumentOperations classes for MongoDB-compatible document operations</li> <li>Database - Main database class for collection management and coordination with MasterIndex</li> <li>DatabaseConfig - Database configuration management with validation and defaults</li> <li>Infrastructure Components - Complete reference for logging, error handling, and ID generation utilities</li> <li>MasterIndex - Cross-instance coordination system using ScriptProperties for virtual locking and conflict detection</li> <li>QueryEngine - Engine for parsing and executing MongoDB-style queries</li> <li>Testing Framework - Comprehensive guide to the GAS DB testing infrastructure, including AssertionUtilities and TestRunner classes</li> <li>UpdateEngine - Engine for applying MongoDB-style update operators to documents</li> </ul>"},{"location":"developers/#coding-standards","title":"Coding Standards","text":"<ul> <li>Linting: <code>no-magic-numbers</code> is enforced as an error for source files to keep configuration and algorithmic values explicit. Tests allow numeric literals for readability because the rule is disabled for <code>tests/**/*.js</code>.</li> <li>Documentation: JSDoc completeness is enforced as errors; ensure descriptions, param types, and return details are present.</li> </ul>"},{"location":"developers/Class_Diagrams/","title":"Class Diagrams for JsonDbApp","text":""},{"location":"developers/Class_Diagrams/#overview","title":"Overview","text":"<p>This document contains updated class diagrams for the JsonDbApp library, optimised for minimal Drive API usage and adherence to SOLID principles. The diagrams reflect the separation of concerns for Collection and FileService components in the MVP.</p> <ul> <li>Class Diagrams for JsonDbApp</li> <li>Overview</li> <li>Main Classes<ul> <li>Database Class Diagram</li> <li>DatabaseConfig Class Diagram</li> <li>Collection Facade and Operations</li> <li>DocumentOperations Class Diagram</li> <li>CollectionMetadata Class Diagram</li> <li>FileService Class Diagram</li> <li>FileOperations Class Diagram</li> <li>QueryEngine</li> <li>UpdateEngine Class Diagram</li> <li>IdGenerator Class Diagram</li> <li>DbLockService Class Diagram</li> <li>JDbLogger Class Diagram</li> <li>ErrorHandler Class Diagram</li> <li>JsonDbError Class Diagram</li> <li>Specific Error Classes</li> <li>MasterIndex Class Diagram</li> </ul> </li> <li>Class Relationships</li> <li>Sequence Diagrams<ul> <li>Document Operation Sequence</li> <li>File Operation Sequence</li> </ul> </li> </ul>"},{"location":"developers/Class_Diagrams/#main-classes","title":"Main Classes","text":""},{"location":"developers/Class_Diagrams/#database-class-diagram","title":"Database Class Diagram","text":"<pre><code>classDiagram\n    class Database {\n        -_config: DatabaseConfig\n        -_masterIndex: MasterIndex\n        -_fileService: FileService\n        -_logger: JDbLogger\n        -_collectionCoordinator: CollectionCoordinator\n        -_initialised: boolean\n        -_collections: Map\n        +constructor(config)\n        +initialise(): void\n        +getCollection(name): Collection\n        +createCollection(name): Collection\n        +listCollections(): String[]\n        +deleteCollection(name): void\n        +backupIndexToDrive(): void\n    +createAndInitialiseDatabase(config): Database\n    +loadDatabase(config): Database\n        -_findOrCreateIndexFile(): String\n        -_createIndexFile(): String\n        -_findExistingIndexFile(): String\n        -_loadCollections(): void\n        -_createCollection(name, fileId): Collection\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#databaseconfig-class-diagram","title":"DatabaseConfig Class Diagram","text":"<pre><code>classDiagram\n    class DatabaseConfig {\n        +rootFolderId: String\n        +autoCreateCollections: Boolean\n        +lockTimeout: Number\n        +cacheEnabled: Boolean\n        +logLevel: String\n        +masterIndexKey: String\n        +retryAttempts: Number\n        +retryDelayMs: Number\n        +constructor(config: Object)\n        +clone(): DatabaseConfig\n        +toJSON(): Object\n        +fromJSON(obj: Object): DatabaseConfig\n        -_getDefaultRootFolder(): String\n        -_validateConfig(): void\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#collection-facade-and-operations","title":"Collection Facade and Operations","text":"<p>The <code>Collection</code> class acts as a facade, delegating operations to specialized handler classes.</p> <pre><code>classDiagram\n    Collection \"1\" --o \"1\" CollectionReadOperations\n    Collection \"1\" --o \"1\" CollectionWriteOperations\n\n    class Collection {\n        -_name: String\n        -_driveFileId: String\n        -_database: Database\n        -_fileService: FileService\n        -_logger: JDbLogger\n        -_loaded: Boolean\n        -_dirty: Boolean\n        -_documents: Object\n        -_metadata: CollectionMetadata\n        -_documentOperations: DocumentOperations\n        -_coordinator: CollectionCoordinator\n        -_readOps: CollectionReadOperations\n        -_writeOps: CollectionWriteOperations\n        +constructor(name, driveFileId, database, fileService)\n        +insertOne(doc): Object\n        +updateOne(filterOrId, update): Object\n        +updateMany(filter, update): Object\n        +replaceOne(filterOrId, doc): Object\n        +deleteOne(filter): Object\n        +deleteMany(filter): Object\n        +findOne(filter): Object|null\n        +find(filter): Array~Object~\n        +countDocuments(filter): Number\n        +aggregate(pipeline): Array\n        +save(): Object\n        +getMetadata(): Object\n        +getName(): String\n        +isDirty(): Boolean\n        +getDriveFileId(): String\n        +getDatabase(): Database\n        +getFileService(): FileService\n        +getLogger(): JDbLogger\n        -_ensureLoaded(): void\n        -_loadData(): void\n        -_saveData(): void\n        -_markDirty(): void\n        -_updateMetadata(changes): void\n        -_validateFilter(filter, operation): void\n    }\n\n    class CollectionReadOperations {\n        -_collection: Collection\n        +constructor(collection)\n        +findOne(filter): Object|null\n        +find(filter): Array~Object~\n        +countDocuments(filter): Number\n        +aggregate(pipeline): Array\n    }\n\n    class CollectionWriteOperations {\n        -_collection: Collection\n        -_coordinator: CollectionCoordinator\n        +constructor(collection)\n        +insertOne(doc): Object\n        +updateOne(filterOrId, update): Object\n        +updateMany(filter, update): Object\n        +replaceOne(filterOrId, doc): Object\n        +deleteOne(filter): Object\n        +deleteMany(filter): Object\n        -_updateOneWithOperators(filter, update): Object\n        -_updateOneWithReplacement(filter, update): Object\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#documentoperations-class-diagram","title":"DocumentOperations Class Diagram","text":"<pre><code>classDiagram\n    class DocumentOperations {\n        -_collection: Collection\n        -_logger: JDbLogger\n        -_queryEngine: QueryEngine\n        -_updateEngine: UpdateEngine\n        +constructor(collection, logger, queryEngine, updateEngine)\n        +insert(doc): Object\n        +find(query): Object[]\n        +findOne(query): Object\n        +count(query): Number\n        +updateOne(query, update): Object\n        +updateMany(query, update): Object\n        +replaceOne(query, replacement): Object\n        +deleteOne(query): Object\n        +deleteMany(query): Object\n        -_validateDoc(doc): void\n        -_validateId(id): void\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#collectionmetadata-class-diagram","title":"CollectionMetadata Class Diagram","text":"<pre><code>classDiagram\n    class CollectionMetadata {\n        +name: String\n        +fileId: String\n        +created: Date\n        +lastUpdated: Date\n        +documentCount: Number\n        +modificationToken: String | null\n        +lockStatus: Object | null\n        +constructor(name: String, fileId: String, initialMetadata?: Object)\n        +updateLastModified(): void\n        +touch(): void\n        +incrementDocumentCount(): void\n        +decrementDocumentCount(): void\n        +setDocumentCount(count: Number): void\n        +getModificationToken(): String | null\n        +setModificationToken(token: String | null): void\n        +getLockStatus(): Object | null\n        +setLockStatus(lockStatus: Object | null): void\n        +toJSON(): Object\n        +clone(): CollectionMetadata\n        +fromJSON(obj: Object): CollectionMetadata\n        +create(name: String, fileId: String): CollectionMetadata\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#fileservice-class-diagram","title":"FileService Class Diagram","text":"<pre><code>classDiagram\n    class FileService {\n        - _fileOps: FileOperations\n        - _logger: JDbLogger\n        - _cache: Map~String,Object~\n        - _maxCacheSize: Number\n        - _cacheEnabled: Boolean\n        +readFile(fileId): Object\n        +writeFile(fileId, data): void\n        +createFile(name, data, folderId): String\n        +deleteFile(fileId): Boolean\n        +fileExists(fileId): Boolean\n        +getFileMetadata(fileId): Object\n        +batchReadFiles(fileIds): Array~Object~\n        +batchGetMetadata(fileIds): Array~Object~\n        +clearCache(): void\n        +getCacheStats(): Object\n        +setCacheEnabled(enabled): void\n        -_addToCache(fileId, content): void\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#fileoperations-class-diagram","title":"FileOperations Class Diagram","text":"<pre><code>classDiagram\n    class FileOperations {\n        - _logger: JDbLogger\n        - _maxRetries: Number\n        - _retryDelayMs: Number\n        +readFile(fileId): Object\n        +writeFile(fileId, data): void\n        +createFile(name, data, folderId): String\n        +deleteFile(fileId): Boolean\n        +fileExists(fileId): Boolean\n        +getFileMetadata(fileId): Object\n        -_handleDriveApiError(error, op, fileId): void\n        -_retryOperation(fn, operationName): *\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#queryengine","title":"QueryEngine","text":"<pre><code>classDiagram\n  class QueryEngine {\n    -_logger: JDbLogger\n    -_config: Object\n    +constructor(logger, config)\n    +find(documents, query): Object[]\n    -_matchDocument(doc, query): boolean\n    -_matchField(value, query): boolean\n    -_validateQuery(query): void\n    -_validateOperator(operator, field, query): void\n    -_validateLogicalQuery(operator, subQueries): void\n    -_validateComparisonQuery(operator, queryValue): void\n  }\n</code></pre>"},{"location":"developers/Class_Diagrams/#updateengine-class-diagram","title":"UpdateEngine Class Diagram","text":"<pre><code>classDiagram\n  class UpdateEngine {\n    -_logger: JDbLogger\n    -_operatorHandlers: Map\n    +constructor(logger)\n    +applyOperators(doc, updateQuery): Object\n    -_applyUpdate(doc, field, operator, value): void\n    -_validateUpdateQuery(updateQuery): void\n    -_getUpdateOperations(updateQuery): Object[]\n    - _handleSet(doc, field, value)\n    - _handleInc(doc, field, value)\n    - _handleMul(doc, field, value)\n    - _handleMin(doc, field, value)\n    - _handleMax(doc, field, value)\n    - _handlePush(doc, field, value)\n    - _handlePull(doc, field, value)\n    - _handleAddToSet(doc, field, value)\n  }\n</code></pre>"},{"location":"developers/Class_Diagrams/#idgenerator-class-diagram","title":"IdGenerator Class Diagram","text":"<pre><code>classDiagram\n    class IdGenerator {\n        +generateUUID(): String\n        +generateFallbackUUID(): String\n        +generateTimestampId(prefix): String\n        +generateShortId(length): String\n        +generateAlphanumericId(length): String\n        +generateNumericId(length): String\n        +generateObjectId(): String\n        +generateSequentialId(prefix): String\n        +generateReadableId(): String\n        +isValidUUID(id): Boolean\n        +isValidObjectId(id): Boolean\n        +getDefaultGenerator(): Function\n        +createCustomGenerator(options): Function\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#dblockservice-class-diagram","title":"DbLockService Class Diagram","text":"<pre><code>classDiagram\n    class DbLockService {\n        -_logger: JDbLogger\n        -_lockTimeout: Number\n        -_scriptLock: Lock | null\n        +constructor(logger, lockTimeout)\n        +acquireScriptLock(): void\n        +releaseScriptLock(): void\n        -_getScriptLock(): Lock\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#jdblogger-class-diagram","title":"JDbLogger Class Diagram","text":"<pre><code>classDiagram\n    class JDbLogger {\n        +LOG_LEVELS: Object\n        +currentLevel: Number\n        +setLevel(level): void\n        +setLevelByName(levelName): void\n        +getLevel(): Number\n        +getLevelName(): String\n        +formatMessage(level, message, context): String\n        +error(message, context): void\n        +warn(message, context): void\n        +info(message, context): void\n        +debug(message, context): void\n        +log(level, message, context): void\n        +createComponentLogger(component): Object\n        +startOperation(operation, context): void\n        +endOperation(operation, duration, context): void\n        +timeOperation(operation, fn, context): *\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#errorhandler-class-diagram","title":"ErrorHandler Class Diagram","text":"<pre><code>classDiagram\n    class ErrorHandler {\n        +ErrorTypes: Object\n        +createError(errorType, ...args): Error\n        +handleError(error, context, rethrow): void\n        +wrapFunction(fn, context): Function\n        +isErrorType(error, errorType): Boolean\n        +extractErrorInfo(error): Object\n        +validateRequired(value, name): void\n        +validateType(value, expectedType, name): void\n        +validateNotEmpty(value, name): void\n        +validateNotEmptyArray(value, name): void\n        +validateRange(value, min, max, name): void\n        +detectDoubleParsing(data, parseError, context): void\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#jsondberror-class-diagram","title":"JsonDbError Class Diagram","text":"<pre><code>classDiagram\n    class JsonDbError {\n        +name: String\n        +message: String\n        +code: String\n        +context: Object\n        +timestamp: Date\n        +constructor(message, code, context): void\n        +toJSON(): Object\n    }\n</code></pre>"},{"location":"developers/Class_Diagrams/#specific-error-classes","title":"Specific Error Classes","text":"<pre><code>classDiagram\n    JsonDbError &lt;|-- ConfigurationError\n    JsonDbError &lt;|-- InvalidArgumentError\n    JsonDbError &lt;|-- DatabaseStateError\n    JsonDbError &lt;|-- FileIOError\n    JsonDbError &lt;|-- FileNotFoundError\n    JsonDbError &lt;|-- MasterIndexError\n    JsonDbError &lt;|-- CollectionNotFoundError\n    JsonDbError &lt;|-- DocumentNotFoundError\n    JsonDbError &lt;|-- DuplicateKeyError\n    JsonDbError &lt;|-- InvalidQueryError\n    JsonDbError &lt;|-- UpdateOperationError\n    JsonDbError &lt;|-- LockTimeoutError\n    JsonDbError &lt;|-- ConflictError\n    JsonDbError &lt;|-- OperationError\n    JsonDbError &lt;|-- SerializationError\n    JsonDbError &lt;|-- DeserializationError\n\n    class ConfigurationError { +constructor(message) }\n    class InvalidArgumentError { +constructor(argName, value, message) }\n    class DatabaseStateError { +constructor(message) }\n    class FileIOError { +constructor(operation, fileId, message) }\n    class FileNotFoundError { +constructor(fileId) }\n    class MasterIndexError { +constructor(message) }\n    class CollectionNotFoundError { +constructor(collectionName) }\n    class DocumentNotFoundError { +constructor(query, collectionName) }\n    class DuplicateKeyError { +constructor(key, value) }\n    class InvalidQueryError { +constructor(message) }\n    class UpdateOperationError { +constructor(message) }\n    class LockTimeoutError { +constructor(lockName, timeout) }\n    class ConflictError { +constructor(message) }\n    class OperationError { +constructor(message) }\n    class SerializationError { +constructor(message) }\n    class DeserializationError { +constructor(message) }\n</code></pre>"},{"location":"developers/Class_Diagrams/#masterindex-class-diagram","title":"MasterIndex Class Diagram","text":"<pre><code>classDiagram\n    class MasterIndex {\n        -_dbLockService: DbLockService\n        -_logger: JDbLogger\n        -_config: Object\n        -_masterIndexData: MasterIndexData\n        -_isInitialised: boolean\n        +constructor(dbLockService, logger, config)\n        +load(): void\n        +isInitialised(): boolean\n        +addCollections(collections): void\n        +getCollectionMetadata(collectionName): Object\n        +updateCollectionMetadata(collectionName, metadata): void\n        +getAllCollections(): Object\n        +removeCollection(collectionName): void\n        +acquireCollectionLock(collectionName, operationId): Object\n        +releaseCollectionLock(collectionName, operationId): void\n        +getCollectionLockStatus(collectionName): Object\n        +cleanupExpiredLocks(): void\n        +save(): void\n        -_loadFromScriptProperties(): void\n        -_saveToScriptProperties(): void\n        -_withScriptLock(operation): *\n        -_isLockExpired(lock): boolean\n    }\n\n    class MasterIndexData {\n        version: String\n        lastUpdated: String\n        collections: Map\n    }\n\n    MasterIndex \"1\" -- \"1\" MasterIndexData : contains\n</code></pre>"},{"location":"developers/Class_Diagrams/#class-relationships","title":"Class Relationships","text":"<pre><code>classDiagram\n    Database \"1\" -- \"1\" DatabaseConfig : uses\n    Database \"1\" -- \"*\" Collection : creates\n    DatabaseConfig \"1\" -- \"1\" Collection : configures\n    Collection \"1\" -- \"1\" CollectionMetadata : contains\n    Collection \"1\" -- \"1\" DocumentOperations : contains\n    DocumentOperations \"1\" -- \"1\" QueryEngine : uses\n    DocumentOperations \"1\" -- \"1\" UpdateEngine : uses\n    QueryEngine \"1\" -- \"1\" ErrorHandler : uses\n    UpdateEngine \"1\" -- \"1\" ErrorHandler : uses\n    ErrorHandler \"1\" -- \"1\" IdGenerator : uses\n    ErrorHandler \"1\" -- \"1\" DbLockService : uses\n    Database \"1\" -- \"1\" FileService : uses\n    FileService \"1\" -- \"1\" Collection : uses\n    FileService \"1\" -- \"1\" FileCache : contains\n    FileService \"1\" -- \"1\" FileOperations : contains\n    FileOperations \"1\" -- \"1\" JDbLogger : uses\n</code></pre>"},{"location":"developers/Class_Diagrams/#sequence-diagrams","title":"Sequence Diagrams","text":""},{"location":"developers/Class_Diagrams/#document-operation-sequence","title":"Document Operation Sequence","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Collection\n    participant DocumentOperations\n    participant FileService\n\n    Client-&gt;&gt;Collection: find(query)\n    Collection-&gt;&gt;Collection: ensureLoaded()\n    Collection-&gt;&gt;DocumentOperations: findDocuments(query)\n    DocumentOperations-&gt;&gt;DocumentOperations: executeQuery()\n    DocumentOperations--&gt;&gt;Collection:\n    Collection--&gt;&gt;Client: matching documents\n</code></pre>"},{"location":"developers/Class_Diagrams/#file-operation-sequence","title":"File Operation Sequence","text":"<pre><code>sequenceDiagram\n    participant C as Collection\n    participant FS as FileService\n    participant FO as FileOperations\n    participant FC as FileCache\n\n    C-&gt;&gt;FS: loadData()\n    FS-&gt;&gt;FC: getCachedFile()\n    FC--&gt;&gt;FS: (data if cached)\n    alt cache miss\n        FS-&gt;&gt;FO: readFile()\n        FO--&gt;&gt;FS: file content\n        FS-&gt;&gt;FC: setFile()\n    end\n    FS--&gt;&gt;C: file data\n</code></pre>"},{"location":"developers/Collection_Components/","title":"Collection Components Developer Guide","text":"<p>This document explains the role, API surface and usage patterns for the Collection, CollectionMetadata, and DocumentOperations classes in JsonDbApp. These three classes work together to provide MongoDB-compatible collection operations with Google Drive persistence.</p> <ul> <li>Collection Components Developer Guide</li> <li>Overview<ul> <li>Architecture</li> <li>Current Limitations (Section 5)</li> </ul> </li> <li>Collection<ul> <li>Purpose</li> <li>Constructor</li> <li>Public Methods</li> <li>insertOne(doc: Object): Object</li> <li>findOne(filter?: Object): Object|null</li> <li>find(filter?: Object): Array</li> <li>updateOne(filter: Object, update: Object): Object</li> <li>updateMany(filter: Object, update: Object): Object</li> <li>replaceOne(filter: Object, replacement: Object): Object</li> <li>deleteOne(filter: Object): Object</li> <li>countDocuments(filter?: Object): number</li> <li>getName(): string</li> <li>getMetadata(): Object</li> <li>isDirty(): boolean</li> <li>save(): void</li> <li>Lazy Loading</li> </ul> </li> <li>CollectionMetadata<ul> <li>Purpose</li> <li>Constructor</li> <li>Public Methods</li> <li><code>updateLastModified(): void</code></li> <li><code>touch(): void</code></li> <li><code>incrementDocumentCount(): void</code></li> <li><code>decrementDocumentCount(): void</code></li> <li><code>setDocumentCount(count: number): void</code></li> <li><code>getModificationToken(): string | null</code></li> <li><code>setModificationToken(token: string | null): void</code></li> <li><code>getLockStatus(): Object | null</code></li> <li><code>setLockStatus(lockStatus: Object | null): void</code></li> <li><code>toJSON(): Object</code></li> <li><code>clone(): CollectionMetadata</code></li> <li>Static Methods</li> <li><code>static fromJSON(obj: Object): CollectionMetadata</code></li> <li><code>static create(name: string, fileId: string): CollectionMetadata</code></li> </ul> </li> <li>DocumentOperations<ul> <li>Purpose</li> <li>Constructor</li> <li>Public Methods</li> <li>insertDocument(doc: Object): Object</li> <li>findDocumentById(id: string): Object|null</li> <li>findAllDocuments(): Array\\&lt;Object&gt;</li> <li>updateDocument(id: string, updateData: Object): Object</li> <li>deleteDocument(id: string): Object</li> <li>countDocuments(): number</li> <li>documentExists(id: string): boolean</li> <li>findByQuery(query: Object): Object|null</li> <li>findMultipleByQuery(query: Object): Array\\&lt;Object&gt;</li> <li>countByQuery(query: Object): number</li> <li>updateDocumentWithOperators(id: string, updateOps: Object): Object</li> <li>updateDocumentByQuery(query: Object, updateOps: Object): number</li> <li>replaceDocument(id: string, doc: Object): Object</li> <li>replaceDocumentByQuery(query: Object, doc: Object): number</li> <li>Private Methods</li> </ul> </li> </ul>"},{"location":"developers/Collection_Components/#overview","title":"Overview","text":"<p>The Collection Components form the core of JsonDbApp's document storage system:</p> <ul> <li>Collection: The main interface providing MongoDB-compatible CRUD operations</li> <li>CollectionMetadata: Manages collection metadata (timestamps, document counts)</li> <li>DocumentOperations: Handles low-level document manipulation</li> </ul>"},{"location":"developers/Collection_Components/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    Collection[Collection (High-level MongoDB API)] --&gt; CollectionMetadata[CollectionMetadata (Metadata management)]\n    Collection --&gt; DocumentOperations[DocumentOperations (Document CRUD operations)]\n    DocumentOperations --&gt; QueryEngine[QueryEngine (Query processing)]\n    DocumentOperations --&gt; UpdateEngine[UpdateEngine (Update operation processing)]\n</code></pre>"},{"location":"developers/Collection_Components/#current-limitations-section-5","title":"Current Limitations (Section 5)","text":"<p>This section describes the capabilities as of Section 5. The <code>Collection</code> class has since been enhanced. Refer to the method descriptions below for current capabilities.</p> <ul> <li>findOne(): Only supports <code>{}</code> (empty) and <code>{_id: \"id\"}</code> filters</li> <li>find(): Only supports <code>{}</code> (empty) filters</li> <li>updateOne(): Only supports <code>{_id: \"id\"}</code> filters, document replacement only (no operators)</li> <li>deleteOne(): Only supports <code>{_id: \"id\"}</code> filters</li> <li>countDocuments(): Only supports <code>{}</code> (empty) filters</li> </ul> <p>Advanced query capabilities will be added in Section 6 (Query Engine) and Section 7 (Update Engine).</p>"},{"location":"developers/Collection_Components/#collection","title":"Collection","text":""},{"location":"developers/Collection_Components/#purpose","title":"Purpose","text":"<p>Collection provides the primary interface for document operations, mimicking MongoDB's collection API whilst managing persistence to Google Drive.</p> <p>Key responsibilities:</p> <ul> <li>MongoDB-compatible CRUD operations</li> <li>Lazy loading from Google Drive</li> <li>Dirty tracking and persistence</li> <li>Integration with CollectionMetadata and DocumentOperations</li> <li>Clear error messages for unsupported features</li> </ul>"},{"location":"developers/Collection_Components/#constructor","title":"Constructor","text":"<pre><code>new Collection(name, driveFileId, database, fileService);\n</code></pre> <ul> <li>name: Collection name (non-empty string)</li> <li>driveFileId: Google Drive file ID for persistence</li> <li>database: Database instance reference</li> <li>fileService: FileService for Drive operations</li> </ul> <p>Throws: <code>InvalidArgumentError</code> for invalid parameters</p> <p>Example:</p> <pre><code>// Typically created by Database class, not directly\nconst collection = new Collection(\n  'users',\n  '1a2b3c4d5e6f7g8h9i0j',\n  databaseInstance,\n  fileServiceInstance\n);\n</code></pre>"},{"location":"developers/Collection_Components/#public-methods","title":"Public Methods","text":""},{"location":"developers/Collection_Components/#insertonedoc-object-object","title":"insertOne(doc: Object): Object","text":"<p>Insert a single document with automatic ID generation.</p> <ul> <li>Parameters</li> <li><code>doc</code>: Document object to insert</li> <li>Returns</li> <li><code>{insertedId: string, acknowledged: boolean}</code></li> <li>Throws</li> <li><code>InvalidArgumentError</code> for invalid documents</li> <li><code>ConflictError</code> for duplicate IDs</li> </ul> <p>Example:</p> <pre><code>// Insert with auto-generated ID\nconst result1 = collection.insertOne({\n  name: 'Alice',\n  email: 'alice@example.com',\n  age: 30\n});\nconsole.log('Generated ID:', result1.insertedId);\n\n// Insert with specific ID\nconst result2 = collection.insertOne({\n  _id: 'user123',\n  name: 'Bob',\n  email: 'bob@example.com'\n});\nconsole.log('Custom ID:', result2.insertedId); // 'user123'\n\n// Error: duplicate ID\ntry {\n  collection.insertOne({ _id: 'user123', name: 'Charlie' });\n} catch (error) {\n  console.error('Conflict:', error.message);\n}\n</code></pre>"},{"location":"developers/Collection_Components/#findonefilter-object-objectnull","title":"findOne(filter?: Object): Object|null","text":"<p>Find a single document matching the filter.</p> <ul> <li>Parameters</li> <li><code>filter</code>: Query filter (supports field-based queries, <code>{_id: \"id\"}</code> and empty <code>{}</code> filters)</li> <li>Returns</li> <li>Document object or <code>null</code> if not found</li> <li>Throws</li> <li><code>InvalidArgumentError</code> for invalid filter structure</li> <li><code>OperationError</code> for unsupported filters</li> </ul> <p>Example:</p> <pre><code>// Find first document (empty filter)\nconst firstDoc = collection.findOne({});\nconsole.log('First document:', firstDoc);\n\n// Find by ID\nconst userDoc = collection.findOne({ _id: 'user123' });\nif (userDoc) {\n  console.log('Found user:', userDoc.name);\n} else {\n  console.log('User not found');\n}\n\n// Find by field\nconst aliceDoc = collection.findOne({ name: 'Alice' });\nif (aliceDoc) {\n  console.log('Found Alice by name:', aliceDoc.email);\n}\n\n// Unsupported filter (throws error)\ntry {\n  collection.findOne({ age: { $gt: 25 } }); // Complex operators may not be supported depending on QueryEngine\n} catch (error) {\n  console.error('Unsupported:', error.message);\n}\n</code></pre>"},{"location":"developers/Collection_Components/#findfilter-object-array","title":"find(filter?: Object): Array","text":"<p>Find multiple documents matching the filter.</p> <ul> <li>Parameters</li> <li><code>filter</code>: Query filter (supports field-based queries and empty <code>{}</code> filter)</li> <li>Returns</li> <li>Array of document objects</li> <li>Throws</li> <li><code>InvalidArgumentError</code> for invalid filter structure</li> <li><code>OperationError</code> for unsupported filters</li> </ul> <p>Example:</p> <pre><code>// Find all documents\nconst allDocs = collection.find({});\nconsole.log('Total documents:', allDocs.length);\n\nallDocs.forEach((doc) =&gt; {\n  console.log('Document ID:', doc._id);\n});\n\n// Find by field\nconst usersOver25 = collection.find({ age: { $gt: 25 } }); // Example, assuming QueryEngine supports $gt\nconsole.log('Users over 25:', usersOver25.length);\n\n// Empty collection returns empty array\nconst emptyResults = emptyCollection.find({});\nconsole.log('Empty results:', emptyResults); // []\n</code></pre>"},{"location":"developers/Collection_Components/#updateonefilter-object-update-object-object","title":"updateOne(filter: Object, update: Object): Object","text":"<p>Update a single document matching the filter.</p> <ul> <li>Parameters</li> <li><code>filter</code>: Query filter (supports field-based queries and <code>{_id: \"id\"}</code> filters)</li> <li><code>update</code>: Document replacement or update operators (e.g. <code>{$set: {field: value}}</code>)</li> <li>Returns</li> <li><code>{matchedCount: number, modifiedCount: number, acknowledged: boolean}</code></li> <li>Throws</li> <li><code>InvalidArgumentError</code> for invalid parameters (filter or update)</li> <li><code>OperationError</code> for unsupported filters or update operators</li> </ul> <p>Example:</p> <pre><code>// Update by ID (document replacement)\nconst updateResult = collection.updateOne(\n  { _id: 'user123' },\n  {\n    // _id: 'user123', // ID is preserved automatically if not specified in replacement\n    name: 'Robert',\n    email: 'robert@example.com',\n    age: 31,\n    lastUpdated: new Date()\n  }\n);\n\nconsole.log('Modified count (replacement):', updateResult.modifiedCount); // 1\n\n// Update by field using $set operator\nconst setResult = collection.updateOne({ email: 'robert@example.com' }, { $set: { age: 32 } });\nconsole.log('Modified count ($set):', setResult.modifiedCount); // 1\n\n// Non-existent document\nconst noMatch = collection.updateOne({ _id: 'nonexistent' }, { name: 'Nobody' });\nconsole.log('No match:', noMatch.modifiedCount); // 0\n\n// Unsupported update operators (throws error)\ntry {\n  collection.updateOne(\n    { _id: 'user123' },\n    { $inc: { age: 1 } } // Assuming $inc is supported by UpdateEngine\n  );\n} catch (error) {\n  console.error('Unsupported operator or error during update:', error.message);\n}\n</code></pre>"},{"location":"developers/Collection_Components/#updatemanyfilter-object-update-object-object","title":"updateMany(filter: Object, update: Object): Object","text":"<p>Update multiple documents matching a filter.</p> <ul> <li>Parameters</li> <li><code>filter</code>: Query filter criteria (supports field-based queries and empty <code>{}</code> filter)</li> <li><code>update</code>: Update operators (e.g. <code>{$set: {field: value}}</code>)</li> <li>Returns</li> <li><code>{matchedCount: number, modifiedCount: number, acknowledged: boolean}</code></li> <li>Throws</li> <li><code>InvalidArgumentError</code> for invalid parameters</li> <li><code>OperationError</code> if update operators are invalid or an error occurs</li> </ul> <p>Example:</p> <pre><code>// Add a 'status' field to all documents\nconst updateManyResult = collection.updateMany(\n  {}, // Empty filter matches all documents\n  { $set: { status: 'active' } }\n);\nconsole.log('Matched:', updateManyResult.matchedCount, 'Modified:', updateManyResult.modifiedCount);\n\n// Update status for users older than 30\nconst updateAdultsResult = collection.updateMany(\n  { age: { $gt: 30 } }, // Assuming QueryEngine supports $gt\n  { $set: { status: 'senior' } }\n);\nconsole.log('Adults updated:', updateAdultsResult.modifiedCount);\n</code></pre>"},{"location":"developers/Collection_Components/#replaceonefilter-object-replacement-object-object","title":"replaceOne(filter: Object, replacement: Object): Object","text":"<p>Replace a single document matching the filter.</p> <ul> <li>Parameters</li> <li><code>filter</code>: Query filter (supports field-based queries and <code>{_id: \"id\"}</code> filters)</li> <li><code>replacement</code>: The new document. Cannot contain update operators. <code>_id</code> if present must match original or be omitted.</li> <li>Returns</li> <li><code>{matchedCount: number, modifiedCount: number, acknowledged: boolean}</code></li> <li>Throws</li> <li><code>InvalidArgumentError</code> for invalid parameters or if replacement contains update operators.</li> </ul> <p>Example:</p> <pre><code>// Replace document by ID\nconst replaceResult = collection.replaceOne(\n  { _id: 'user123' },\n  { name: 'Bobby Tables', email: 'bobby@example.com', age: 25 } // _id will be preserved\n);\nconsole.log('Replaced count:', replaceResult.modifiedCount); // 1\n\n// Attempt to replace with update operators (will throw error)\ntry {\n  collection.replaceOne({ _id: 'user123' }, { $set: { name: 'Not Allowed' } });\n} catch (error) {\n  console.error('Error:', error.message); // Should indicate $set is not allowed\n}\n</code></pre>"},{"location":"developers/Collection_Components/#deleteonefilter-object-object","title":"deleteOne(filter: Object): Object","text":"<p>Delete a single document matching the filter.</p> <ul> <li>Parameters</li> <li><code>filter</code>: Query filter (supports field-based queries and <code>{_id: \"id\"}</code> filters)</li> <li>Returns</li> </ul> <p><code>{deletedCount: number, acknowledged: boolean}</code></p> <ul> <li>Throws</li> <li><code>InvalidArgumentError</code> for invalid filter structure</li> <li><code>OperationError</code> for unsupported filters</li> </ul> <p>Example:</p> <pre><code>// Delete by ID\nconst deleteResult = collection.deleteOne({ _id: 'user123' });\nconsole.log('Deleted count by ID:', deleteResult.deletedCount); // 1\n\n// Delete by field\nconst deleteByEmailResult = collection.deleteOne({ email: 'alice@example.com' });\nconsole.log('Deleted count by email:', deleteByEmailResult.deletedCount); // 1\n\n// Non-existent document\nconst noDelete = collection.deleteOne({ _id: 'nonexistent' });\nconsole.log('Nothing deleted:', noDelete.deletedCount); // 0\n\n// Document no longer exists\nconst gone = collection.findOne({ _id: 'user123' });\nconsole.log('Document gone:', gone); // null\n</code></pre>"},{"location":"developers/Collection_Components/#countdocumentsfilter-object-number","title":"countDocuments(filter?: Object): number","text":"<p>Count documents matching the filter.</p> <ul> <li>Parameters</li> <li><code>filter</code>: Query filter (supports field-based queries and empty <code>{}</code> filter)</li> <li>Returns</li> </ul> <p>Number of matching documents</p> <ul> <li>Throws</li> <li><code>InvalidArgumentError</code> for invalid filter structure</li> <li><code>OperationError</code> for unsupported filters</li> </ul> <p>Example:</p> <pre><code>// Count all documents\nconst totalCount = collection.countDocuments({});\nconsole.log('Total documents:', totalCount);\n\n// Count documents matching a filter\nconst countOver30 = collection.countDocuments({ age: { $gt: 30 } }); // Assuming QueryEngine supports $gt\nconsole.log('Documents with age &gt; 30:', countOver30);\n\n// Empty collection\nconst emptyCount = emptyCollection.countDocuments();\nconsole.log('Empty count:', emptyCount); // 0\n\n// Verify count matches find() results\nconst allDocs = collection.find({});\nconsole.log('Count matches:', totalCount === allDocs.length); // true\n</code></pre>"},{"location":"developers/Collection_Components/#getname-string","title":"getName(): string","text":"<p>Get the collection name.</p> <pre><code>const name = collection.getName();\nconsole.log('Collection name:', name); // 'users'\n</code></pre>"},{"location":"developers/Collection_Components/#getmetadata-object","title":"getMetadata(): Object","text":"<p>Get collection metadata.</p> <ul> <li>Returns</li> <li><code>{created: Date, lastUpdated: Date, documentCount: number}</code></li> </ul> <pre><code>const metadata = collection.getMetadata();\nconsole.log('Created:', metadata.created);\nconsole.log('Last updated:', metadata.lastUpdated);\nconsole.log('Document count:', metadata.documentCount);\n</code></pre>"},{"location":"developers/Collection_Components/#isdirty-boolean","title":"isDirty(): boolean","text":"<p>Check if collection has unsaved changes.</p> <pre><code>console.log('Has changes:', collection.isDirty()); // false\n\ncollection.insertOne({ name: 'Test' });\nconsole.log('Has changes:', collection.isDirty()); // true\n\ncollection.save();\nconsole.log('Has changes:', collection.isDirty()); // false\n</code></pre>"},{"location":"developers/Collection_Components/#save-void","title":"save(): void","text":"<p>Force save collection to Drive.</p> <ul> <li>Throws: <code>OperationError</code> if save fails</li> </ul> <pre><code>// Manual save (usually automatic)\ntry {\n  collection.save();\n  console.log('Collection saved');\n} catch (error) {\n  console.error('Save failed:', error.message);\n}\n</code></pre>"},{"location":"developers/Collection_Components/#lazy-loading","title":"Lazy Loading","text":"<p>Collections use lazy loading for performance:</p> <pre><code>const collection = new Collection(...); // No Drive access yet\n\nconst metadata = collection.getMetadata(); // Triggers loading\nconst docs = collection.find({}); // Already loaded, no Drive access\n</code></pre>"},{"location":"developers/Collection_Components/#collectionmetadata","title":"CollectionMetadata","text":""},{"location":"developers/Collection_Components/#purpose_1","title":"Purpose","text":"<p><code>CollectionMetadata</code> manages essential information about a collection. This includes its identity (name and file ID), timestamps for creation and updates, the number of documents it contains, a token for managing concurrent modifications, and its current lock status. It ensures that metadata is always in a valid state and provides methods for its manipulation and serialisation.</p>"},{"location":"developers/Collection_Components/#constructor_1","title":"Constructor","text":"<pre><code>new CollectionMetadata(name: string, fileId: string, initialMetadata?: Object)\n</code></pre> <p>or (legacy support)</p> <pre><code>new CollectionMetadata(initialMetadata: Object)\n</code></pre> <ul> <li>name (string): The name of the collection. This is a required field.</li> <li>fileId (string): The Google Drive file ID where the collection data is stored. This is a required field.</li> <li>initialMetadata (optional Object): An object containing initial values for metadata properties.</li> <li><code>created</code>: Creation timestamp (Date). Defaults to the current time.</li> <li><code>lastUpdated</code>: Last update timestamp (Date). Defaults to the current time.</li> <li><code>documentCount</code>: Document count (integer \u2265 0). Defaults to 0.</li> <li><code>modificationToken</code>: A string token for optimistic locking, or <code>null</code>. Defaults to <code>null</code>.</li> <li><code>lockStatus</code>: An object detailing the lock state, or <code>null</code>. Defaults to <code>null</code>.<ul> <li><code>isLocked</code>: (boolean) Whether the collection is locked.</li> <li><code>lockedBy</code>: (string|null) Identifier of the process/user holding the lock.</li> <li><code>lockedAt</code>: (number|null) Timestamp (epoch milliseconds) when the lock was acquired.</li> <li><code>lockTimeout</code>: (number|null) Duration in milliseconds for which the lock is valid.</li> </ul> </li> </ul> <p>Throws: <code>InvalidArgumentError</code> for invalid or missing <code>name</code>, <code>fileId</code>, or other metadata values.</p> <p>Example:</p> <pre><code>// Create with name, fileId, and defaults for other properties\nconst metadata1 = new CollectionMetadata('users', 'fileId123');\nconsole.log('Collection Name:', metadata1.name); // 'users'\nconsole.log('File ID:', metadata1.fileId); // 'fileId123'\nconsole.log('Default count:', metadata1.documentCount); // 0\n\n// Create with name, fileId, and specific initial values\nconst metadata2 = new CollectionMetadata('products', 'fileId456', {\n  created: new Date('2023-01-01'),\n  lastUpdated: new Date('2023-06-15'),\n  documentCount: 42,\n  modificationToken: 'initialToken123',\n  lockStatus: { isLocked: false, lockedBy: null, lockedAt: null, lockTimeout: null }\n});\nconsole.log('Product count:', metadata2.documentCount); // 42\nconsole.log('Modification Token:', metadata2.getModificationToken()); // 'initialToken123'\n\n// Invalid values throw errors\ntry {\n  new CollectionMetadata('', 'fileId789'); // Empty name\n} catch (error) {\n  console.error('Invalid name:', error.message);\n}\n\ntry {\n  new CollectionMetadata('orders', null); // Missing fileId\n} catch (error) {\n  console.error('Invalid fileId:', error.message);\n}\n\ntry {\n  new CollectionMetadata('inventory', 'fileIdABC', { documentCount: -1 });\n} catch (error) {\n  console.error('Invalid count:', error.message);\n}\n</code></pre>"},{"location":"developers/Collection_Components/#public-methods_1","title":"Public Methods","text":""},{"location":"developers/Collection_Components/#updatelastmodified-void","title":"<code>updateLastModified(): void</code>","text":"<p>Updates the <code>lastUpdated</code> timestamp to the current time.</p> <pre><code>const metadata = new CollectionMetadata('logs', 'logFileId');\nconst oldTime = metadata.lastUpdated;\n\n// Wait a moment...\nsetTimeout(() =&gt; {\n  metadata.updateLastModified();\n  console.log('Updated:', metadata.lastUpdated &gt; oldTime); // true\n}, 10);\n</code></pre>"},{"location":"developers/Collection_Components/#touch-void","title":"<code>touch(): void</code>","text":"<p>Alias for <code>updateLastModified()</code>. Updates the <code>lastUpdated</code> timestamp to the current time. This is typically used to signify that the collection metadata has been accessed or \"touched\" without necessarily changing other data like document count.</p> <pre><code>const metadata = new CollectionMetadata('cache', 'cacheFileId');\nconst oldTime = metadata.lastUpdated;\nmetadata.touch();\nconsole.log('Touched, lastUpdated changed:', metadata.lastUpdated &gt; oldTime); // true (assuming a slight delay)\n</code></pre>"},{"location":"developers/Collection_Components/#incrementdocumentcount-void","title":"<code>incrementDocumentCount(): void</code>","text":"<p>Increments the <code>documentCount</code> by 1 and updates the <code>lastUpdated</code> timestamp.</p> <pre><code>const metadata = new CollectionMetadata('tasks', 'tasksFileId');\nconsole.log('Initial count:', metadata.documentCount); // 0\n\nmetadata.incrementDocumentCount();\nconsole.log('After increment:', metadata.documentCount); // 1\n</code></pre>"},{"location":"developers/Collection_Components/#decrementdocumentcount-void","title":"<code>decrementDocumentCount(): void</code>","text":"<p>Decrements the <code>documentCount</code> by 1 and updates the <code>lastUpdated</code> timestamp.</p> <ul> <li>Throws: <code>InvalidArgumentError</code> if <code>documentCount</code> would go below zero.</li> </ul> <pre><code>const metadata = new CollectionMetadata('items', 'itemsFileId', { documentCount: 5 });\n\nmetadata.decrementDocumentCount();\nconsole.log('After decrement:', metadata.documentCount); // 4\n\n// Cannot go below zero\ntry {\n  const emptyMetadata = new CollectionMetadata('empty', 'emptyFileId', { documentCount: 0 });\n  emptyMetadata.decrementDocumentCount(); // Throws error\n} catch (error) {\n  console.error('Cannot decrement:', error.message);\n}\n</code></pre>"},{"location":"developers/Collection_Components/#setdocumentcountcount-number-void","title":"<code>setDocumentCount(count: number): void</code>","text":"<p>Sets the <code>documentCount</code> to a specific value and updates the <code>lastUpdated</code> timestamp.</p> <ul> <li>Parameters:</li> <li><code>count</code>: The new document count (must be an integer \u2265 0).</li> <li>Throws: <code>InvalidArgumentError</code> for invalid <code>count</code> values (e.g., negative, not an integer).</li> </ul> <pre><code>const metadata = new CollectionMetadata('notes', 'notesFileId');\n\nmetadata.setDocumentCount(100);\nconsole.log('Set count:', metadata.documentCount); // 100\n\n// Invalid values throw errors\ntry {\n  metadata.setDocumentCount(-5); // Throws error\n} catch (error) {\n  console.error('Invalid count for setDocumentCount:', error.message);\n}\n</code></pre>"},{"location":"developers/Collection_Components/#getmodificationtoken-string-null","title":"<code>getModificationToken(): string | null</code>","text":"<p>Returns the current <code>modificationToken</code>. This token can be used for optimistic concurrency control.</p> <pre><code>const metadata = new CollectionMetadata('configs', 'configsFileId', { modificationToken: 'v1' });\nconsole.log(metadata.getModificationToken()); // 'v1'\n</code></pre>"},{"location":"developers/Collection_Components/#setmodificationtokentoken-string-null-void","title":"<code>setModificationToken(token: string | null): void</code>","text":"<p>Sets the <code>modificationToken</code>.</p> <ul> <li>Parameters:</li> <li><code>token</code>: The new modification token (string or <code>null</code>). Must be a non-empty string if not <code>null</code>.</li> <li>Throws: <code>InvalidArgumentError</code> for invalid token values.</li> </ul> <pre><code>const metadata = new CollectionMetadata('settings', 'settingsFileId');\nmetadata.setModificationToken('v2-alpha');\nconsole.log(metadata.getModificationToken()); // 'v2-alpha'\n\nmetadata.setModificationToken(null);\nconsole.log(metadata.getModificationToken()); // null\n\ntry {\n  metadata.setModificationToken(''); // Empty string\n} catch (error) {\n  console.error('Invalid token:', error.message);\n}\n</code></pre>"},{"location":"developers/Collection_Components/#getlockstatus-object-null","title":"<code>getLockStatus(): Object | null</code>","text":"<p>Returns the current <code>lockStatus</code> object or <code>null</code> if no lock information is set. The <code>lockStatus</code> object has the shape: <code>{ isLocked: boolean, lockedBy: string|null, lockedAt: number|null, lockTimeout: number|null }</code>.</p> <pre><code>const lockInfo = {\n  isLocked: true,\n  lockedBy: 'process-1',\n  lockedAt: Date.now(),\n  lockTimeout: 30000\n};\nconst metadata = new CollectionMetadata('jobs', 'jobsFileId', { lockStatus: lockInfo });\nconsole.log(metadata.getLockStatus()); // { isLocked: true, ... }\n</code></pre>"},{"location":"developers/Collection_Components/#setlockstatuslockstatus-object-null-void","title":"<code>setLockStatus(lockStatus: Object | null): void</code>","text":"<p>Sets the <code>lockStatus</code>.</p> <ul> <li>Parameters:</li> <li><code>lockStatus</code>: The new lock status object or <code>null</code>. If an object, it must conform to the required structure and types.</li> <li>Throws: <code>InvalidArgumentError</code> for invalid <code>lockStatus</code> object structure or values.</li> </ul> <pre><code>const metadata = new CollectionMetadata('queue', 'queueFileId');\nconst newLock = {\n  isLocked: true,\n  lockedBy: 'worker-bee',\n  lockedAt: Date.now(),\n  lockTimeout: 60000\n};\nmetadata.setLockStatus(newLock);\nconsole.log(metadata.getLockStatus()); // { isLocked: true, lockedBy: 'worker-bee', ... }\n\nmetadata.setLockStatus(null);\nconsole.log(metadata.getLockStatus()); // null\n\ntry {\n  metadata.setLockStatus({ isLocked: 'yes' }); // Invalid type for isLocked\n} catch (error) {\n  console.error('Invalid lock status:', error.message);\n}\n</code></pre>"},{"location":"developers/Collection_Components/#tojson-object","title":"<code>toJSON(): Object</code>","text":"<p>Returns the metadata as a plain JavaScript object, suitable for <code>JSON.stringify()</code>. This method includes a <code>__type</code> property for potential deserialisation and ensures all date properties are new <code>Date</code> instances.</p> <ul> <li>Returns: A plain object with all metadata properties:   <code>{ __type: 'CollectionMetadata', name: string, fileId: string, created: Date, lastUpdated: Date, documentCount: number, modificationToken: string|null, lockStatus: Object|null }</code></li> </ul> <pre><code>const metadata = new CollectionMetadata('dataEntries', 'dataFileId1', {\n  documentCount: 10,\n  modificationToken: 'token-xyz'\n});\nconst obj = metadata.toJSON();\n\nconsole.log('Plain object:', obj);\n/*\n{\n  __type: 'CollectionMetadata',\n  name: 'dataEntries',\n  fileId: 'dataFileId1',\n  created: Date, // (a new Date instance)\n  lastUpdated: Date, // (a new Date instance)\n  documentCount: 10,\n  modificationToken: 'token-xyz',\n  lockStatus: null\n}\n*/\n\n// Dates are independent copies\nconst originalCreationYear = metadata.created.getFullYear();\nobj.created.setFullYear(2000);\nconsole.log(\n  'Original created year unchanged:',\n  metadata.created.getFullYear() === originalCreationYear\n); // true\n</code></pre>"},{"location":"developers/Collection_Components/#clone-collectionmetadata","title":"<code>clone(): CollectionMetadata</code>","text":"<p>Creates and returns a new <code>CollectionMetadata</code> instance that is an independent, deep copy of the original.</p> <pre><code>const original = new CollectionMetadata('source', 'sourceFile', { documentCount: 5 });\nconst copy = original.clone();\n\ncopy.incrementDocumentCount();\nconsole.log('Original unchanged:', original.documentCount); // 5\nconsole.log('Copy changed:', copy.documentCount); // 6\n\n// Ensure deep copy of nested objects like lockStatus if present\nconst lock = { isLocked: true, lockedBy: 'test', lockedAt: Date.now(), lockTimeout: 1000 };\nconst originalWithLock = new CollectionMetadata('lockedColl', 'lockFile', { lockStatus: lock });\nconst copyWithLock = originalWithLock.clone();\ncopyWithLock.getLockStatus().isLocked = false;\n\nconsole.log('Original lock status unchanged:', originalWithLock.getLockStatus().isLocked); // true\nconsole.log('Copy lock status changed:', copyWithLock.getLockStatus().isLocked); // false\n</code></pre>"},{"location":"developers/Collection_Components/#static-methods","title":"Static Methods","text":""},{"location":"developers/Collection_Components/#static-fromjsonobj-object-collectionmetadata","title":"<code>static fromJSON(obj: Object): CollectionMetadata</code>","text":"<p>Creates a <code>CollectionMetadata</code> instance from a plain JavaScript object (typically one produced by <code>toJSON()</code>).</p> <ul> <li>Parameters:</li> <li><code>obj</code>: A plain object containing metadata properties.</li> <li>Returns: A new <code>CollectionMetadata</code> instance.</li> <li>Throws: <code>InvalidArgumentError</code> if the input object is invalid or missing required properties.</li> </ul> <pre><code>const plainObject = {\n  name: 'deserialisedCollection',\n  fileId: 'deserialisedFileId',\n  created: new Date('2022-01-01T10:00:00Z').toISOString(), // Dates can be ISO strings or Date objects\n  lastUpdated: new Date('2022-01-02T11:00:00Z'),\n  documentCount: 15,\n  modificationToken: 'tokenFromObject',\n  lockStatus: null\n};\n\n// Note: For fromJSON to correctly parse date strings, they should be in a format\n// that the Date constructor can parse, or be actual Date objects.\n// The constructor of CollectionMetadata handles new Date(value) for date fields.\n\nconst metadataInstance = CollectionMetadata.fromJSON(plainObject);\nconsole.log('Instance name:', metadataInstance.name); // 'deserialisedCollection'\nconsole.log('Instance document count:', metadataInstance.documentCount); // 15\nconsole.log('Instance modification token:', metadataInstance.getModificationToken()); // 'tokenFromObject'\n</code></pre>"},{"location":"developers/Collection_Components/#static-createname-string-fileid-string-collectionmetadata","title":"<code>static create(name: string, fileId: string): CollectionMetadata</code>","text":"<p>A static factory method to create a new <code>CollectionMetadata</code> instance with the specified <code>name</code> and <code>fileId</code>, and default values for other properties.</p> <ul> <li>Parameters:</li> <li><code>name</code>: The collection name.</li> <li><code>fileId</code>: The Google Drive file ID.</li> <li>Returns: A new <code>CollectionMetadata</code> instance.</li> <li>Throws: <code>InvalidArgumentError</code> if <code>name</code> or <code>fileId</code> are invalid.</li> </ul> <pre><code>const newMetadata = CollectionMetadata.create('newCollection', 'newFileIdXYZ');\nconsole.log('Created name:', newMetadata.name); // 'newCollection'\nconsole.log('Created fileId:', newMetadata.fileId); // 'newFileIdXYZ'\nconsole.log('Created doc count:', newMetadata.documentCount); // 0\n</code></pre>"},{"location":"developers/Collection_Components/#documentoperations","title":"DocumentOperations","text":""},{"location":"developers/Collection_Components/#purpose_2","title":"Purpose","text":"<p><code>DocumentOperations</code> is a low-level component responsible for the direct manipulation of documents within a collection's in-memory representation. It provides the core Create, Read, Update, and Delete (CRUD) functionalities that are utilised by the higher-level <code>Collection</code> class. <code>DocumentOperations</code> itself does not interact with the file system or manage metadata; its focus is solely on operating on the JavaScript objects that represent documents.</p> <p>It works in conjunction with:</p> <ul> <li>Collection: The <code>Collection</code> class instantiates and uses <code>DocumentOperations</code> to perform actions on its <code>_documents</code> object.</li> <li>QueryEngine: For <code>findByQuery</code>, <code>findMultipleByQuery</code>, and <code>countByQuery</code> methods, <code>DocumentOperations</code> delegates the filtering logic to the <code>QueryEngine</code>.</li> <li>UpdateEngine: For <code>updateDocumentWithOperators</code> and <code>updateDocumentByQuery</code> methods, <code>DocumentOperations</code> uses the <code>UpdateEngine</code> to apply complex update operations.</li> </ul>"},{"location":"developers/Collection_Components/#constructor_2","title":"Constructor","text":"<pre><code>new DocumentOperations(collection);\n</code></pre> <ul> <li>collection: A reference to the <code>Collection</code> instance. This provides <code>DocumentOperations</code> access to the actual documents array (<code>collection._documents</code>) and methods to update metadata (<code>collection._updateMetadata()</code>) and mark the collection as dirty (<code>collection._markDirty()</code>).</li> </ul> <p>Throws: <code>InvalidArgumentError</code> if the <code>collection</code> parameter is not a valid <code>Collection</code> instance (though this is typically ensured by the <code>Collection</code> class itself).</p> <p>Example:</p> <pre><code>// Typically created by the Collection class, not directly\n// Assuming 'this' is an instance of the Collection class\nthis._documentOperations = new DocumentOperations(this);\n</code></pre>"},{"location":"developers/Collection_Components/#public-methods_2","title":"Public Methods","text":""},{"location":"developers/Collection_Components/#insertdocumentdoc-object-object","title":"insertDocument(doc: Object): Object","text":"<p>Inserts a single document into the collection's internal <code>_documents</code> object. If the document does not have an <code>_id</code> field, one is generated.</p> <ul> <li>Parameters</li> <li><code>doc</code>: The document object to insert.</li> <li>Returns</li> <li>The inserted document, including its <code>_id</code>.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If the document is invalid (e.g., <code>null</code>, not an object, or contains invalid field names).</li> <li><code>ErrorHandler.ErrorTypes.CONFLICT_ERROR</code>: If a document with the same <code>_id</code> already exists.</li> </ul> <p>Example:</p> <pre><code>// Assuming docOps is an instance of DocumentOperations\nconst newDoc = docOps.insertDocument({ name: 'Alice', age: 30 });\nconsole.log('Inserted document ID:', newDoc._id);\n\ntry {\n  docOps.insertDocument({ _id: newDoc._id, name: 'Bob' });\n} catch (e) {\n  console.error(e.message); // Conflict error\n}\n</code></pre>"},{"location":"developers/Collection_Components/#finddocumentbyidid-string-objectnull","title":"findDocumentById(id: string): Object|null","text":"<p>Retrieves a document by its <code>_id</code>.</p> <ul> <li>Parameters</li> <li><code>id</code>: The <code>_id</code> of the document to find.</li> <li>Returns</li> <li>The found document object, or <code>null</code> if no document with that <code>_id</code> exists.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If the <code>id</code> is invalid (e.g., not a string or empty).</li> </ul> <p>Example:</p> <pre><code>const user = docOps.findDocumentById('some-unique-id');\nif (user) {\n  console.log('Found user:', user.name);\n} else {\n  console.log('User not found.');\n}\n</code></pre>"},{"location":"developers/Collection_Components/#findalldocuments-arrayobject","title":"findAllDocuments(): Array&lt;Object&gt;","text":"<p>Retrieves all documents currently held in the collection's <code>_documents</code> object.</p> <ul> <li>Returns</li> <li>An array of all document objects. Returns an empty array if the collection is empty.</li> </ul> <p>Example:</p> <pre><code>const allUsers = docOps.findAllDocuments();\nconsole.log(`There are ${allUsers.length} users.`);\n</code></pre>"},{"location":"developers/Collection_Components/#updatedocumentid-string-updatedata-object-object","title":"updateDocument(id: string, updateData: Object): Object","text":"<p>Replaces the entire document identified by <code>id</code> with <code>updateData</code>. This is a full replacement, not a partial update. The <code>_id</code> in <code>updateData</code> must match the <code>id</code> parameter if provided, or <code>updateData</code> should not contain an <code>_id</code> (in which case the original <code>_id</code> is preserved).</p> <ul> <li>Parameters</li> <li><code>id</code>: The <code>_id</code> of the document to update.</li> <li><code>updateData</code>: The new document data.</li> <li>Returns</li> <li>An object <code>{ acknowledged: boolean, modifiedCount: number }</code>. <code>modifiedCount</code> is 1 if the document was found and updated, 0 otherwise.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If <code>id</code> or <code>updateData</code> is invalid, or if <code>updateData._id</code> is present and does not match <code>id</code>.</li> <li><code>ErrorHandler.ErrorTypes.DOCUMENT_NOT_FOUND</code>: If no document with the given <code>id</code> exists. (Note: current implementation returns <code>modifiedCount: 0</code> instead of throwing)</li> </ul> <p>Example:</p> <pre><code>const result = docOps.updateDocument('some-unique-id', { name: 'Alice Smith', age: 31 });\nif (result.modifiedCount &gt; 0) {\n  console.log('Document updated.');\n} else {\n  console.log('Document not found or not modified.');\n}\n</code></pre>"},{"location":"developers/Collection_Components/#deletedocumentid-string-object","title":"deleteDocument(id: string): Object","text":"<p>Deletes a document by its <code>_id</code>.</p> <ul> <li>Parameters</li> <li><code>id</code>: The <code>_id</code> of the document to delete.</li> <li>Returns</li> <li>An object <code>{ acknowledged: boolean, deletedCount: number }</code>. <code>deletedCount</code> is 1 if the document was found and deleted, 0 otherwise.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If the <code>id</code> is invalid.</li> </ul> <p>Example:</p> <pre><code>const result = docOps.deleteDocument('some-unique-id');\nif (result.deletedCount &gt; 0) {\n  console.log('Document deleted.');\n} else {\n  console.log('Document not found.');\n}\n</code></pre>"},{"location":"developers/Collection_Components/#countdocuments-number","title":"countDocuments(): number","text":"<p>Counts the total number of documents in the collection.</p> <ul> <li>Returns</li> <li>The total number of documents.</li> </ul> <p>Example:</p> <pre><code>const count = docOps.countDocuments();\nconsole.log(`Total documents: ${count}`);\n</code></pre>"},{"location":"developers/Collection_Components/#documentexistsid-string-boolean","title":"documentExists(id: string): boolean","text":"<p>Checks if a document with the given <code>_id</code> exists.</p> <ul> <li>Parameters</li> <li><code>id</code>: The <code>_id</code> to check.</li> <li>Returns</li> <li><code>true</code> if a document with the <code>_id</code> exists, <code>false</code> otherwise.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If the <code>id</code> is invalid.</li> </ul> <p>Example:</p> <pre><code>if (docOps.documentExists('some-unique-id')) {\n  console.log('Document exists.');\n}\n</code></pre>"},{"location":"developers/Collection_Components/#findbyqueryquery-object-objectnull","title":"findByQuery(query: Object): Object|null","text":"<p>Finds the first document that matches the given query. Delegates to <code>QueryEngine</code>.</p> <ul> <li>Parameters</li> <li><code>query</code>: A MongoDB-compatible query object.</li> <li>Returns</li> <li>The first matching document, or <code>null</code> if no documents match.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If the query is invalid.</li> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If the query contains invalid operators (as determined by <code>QueryEngine</code>).</li> </ul> <p>Example:</p> <pre><code>const user = docOps.findByQuery({ age: { $gt: 30 } });\nif (user) {\n  console.log('Found user older than 30:', user.name);\n}\n</code></pre>"},{"location":"developers/Collection_Components/#findmultiplebyqueryquery-object-arrayobject","title":"findMultipleByQuery(query: Object): Array&lt;Object&gt;","text":"<p>Finds all documents that match the given query. Delegates to <code>QueryEngine</code>.</p> <ul> <li>Parameters</li> <li><code>query</code>: A MongoDB-compatible query object.</li> <li>Returns</li> <li>An array of matching documents. Returns an empty array if no documents match.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If the query is invalid.</li> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If the query contains invalid operators.</li> </ul> <p>Example:</p> <pre><code>const admins = docOps.findMultipleByQuery({ role: 'admin' });\nadmins.forEach((admin) =&gt; console.log(admin.name));\n</code></pre>"},{"location":"developers/Collection_Components/#countbyqueryquery-object-number","title":"countByQuery(query: Object): number","text":"<p>Counts documents that match the given query. Delegates to <code>QueryEngine</code>.</p> <ul> <li>Parameters</li> <li><code>query</code>: A MongoDB-compatible query object.</li> <li>Returns</li> <li>The number of matching documents.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If the query is invalid.</li> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If the query contains invalid operators.</li> </ul> <p>Example:</p> <pre><code>const activeUserCount = docOps.countByQuery({ status: 'active' });\nconsole.log(`Number of active users: ${activeUserCount}`);\n</code></pre>"},{"location":"developers/Collection_Components/#updatedocumentwithoperatorsid-string-updateops-object-object","title":"updateDocumentWithOperators(id: string, updateOps: Object): Object","text":"<p>Updates a single document identified by <code>id</code> using MongoDB-style update operators (e.g., <code>$set</code>, <code>$inc</code>). Delegates to <code>UpdateEngine</code>.</p> <ul> <li>Parameters</li> <li><code>id</code>: The <code>_id</code> of the document to update.</li> <li><code>updateOps</code>: An object containing update operator instructions.</li> <li>Returns</li> <li>An object <code>{ acknowledged: boolean, modifiedCount: number }</code>.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If <code>id</code> or <code>updateOps</code> are invalid.</li> <li><code>ErrorHandler.ErrorTypes.DOCUMENT_NOT_FOUND</code>: If no document with the given <code>id</code> exists.</li> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If <code>updateOps</code> are invalid (as determined by <code>UpdateEngine</code>).</li> </ul> <p>Example:</p> <pre><code>const result = docOps.updateDocumentWithOperators('some-unique-id', {\n  $set: { status: 'inactive' },\n  $inc: { loginAttempts: 1 }\n});\nif (result.modifiedCount &gt; 0) {\n  console.log('Document updated with operators.');\n}\n</code></pre>"},{"location":"developers/Collection_Components/#updatedocumentbyqueryquery-object-updateops-object-number","title":"updateDocumentByQuery(query: Object, updateOps: Object): number","text":"<p>Updates all documents matching the <code>query</code> using MongoDB-style update operators. Delegates to <code>QueryEngine</code> for finding documents and <code>UpdateEngine</code> for applying updates.</p> <ul> <li>Parameters</li> <li><code>query</code>: The filter criteria to select documents for update.</li> <li><code>updateOps</code>: The update operator instructions.</li> <li>Returns</li> <li>The number of documents modified.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If <code>query</code> or <code>updateOps</code> are invalid.</li> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If <code>updateOps</code> are invalid.     (Note: <code>DOCUMENT_NOT_FOUND</code> is listed in JSDoc but typically results in 0 modified documents rather than an error for \"update many\" type operations).</li> </ul> <p>Example:</p> <pre><code>const updatedCount = docOps.updateDocumentByQuery(\n  { department: 'Sales' },\n  { $set: { onQuota: true } }\n);\nconsole.log(`${updatedCount} sales documents updated.`);\n</code></pre>"},{"location":"developers/Collection_Components/#replacedocumentid-string-doc-object-object","title":"replaceDocument(id: string, doc: Object): Object","text":"<p>Replaces a single document identified by <code>id</code> with the new <code>doc</code>. The <code>_id</code> in <code>doc</code> must match <code>id</code> or be omitted.</p> <ul> <li>Parameters</li> <li><code>id</code>: The <code>_id</code> of the document to replace.</li> <li><code>doc</code>: The replacement document.</li> <li>Returns</li> <li>An object <code>{ acknowledged: boolean, modifiedCount: number }</code>.</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If <code>id</code> or <code>doc</code> is invalid, or if <code>doc._id</code> is present and mismatches <code>id</code>.</li> <li><code>ErrorHandler.ErrorTypes.DOCUMENT_NOT_FOUND</code>: If no document with the given <code>id</code> exists.</li> </ul> <p>Example:</p> <pre><code>const result = docOps.replaceDocument('some-unique-id', { name: 'New Name', value: 'New Value' });\nif (result.modifiedCount &gt; 0) {\n  console.log('Document replaced.');\n}\n</code></pre>"},{"location":"developers/Collection_Components/#replacedocumentbyqueryquery-object-doc-object-number","title":"replaceDocumentByQuery(query: Object, doc: Object): number","text":"<p>Replaces the first document matching the <code>query</code> with the new <code>doc</code>. Note: MongoDB's <code>replaceOne</code> is more aligned with <code>replaceDocument</code>. This method's name might be slightly misleading if it replaces multiple, but the current implementation seems to target one. If it's intended to replace multiple, the return type and logic would differ. Assuming it replaces one based on typical <code>replace</code> semantics.</p> <ul> <li>Parameters</li> <li><code>query</code>: The filter criteria to select the document for replacement.</li> <li><code>doc</code>: The replacement document.</li> <li>Returns</li> <li>The number of documents replaced (0 or 1).</li> <li>Throws</li> <li><code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code>: If <code>query</code> or <code>doc</code> is invalid.</li> </ul> <p>Example:</p> <pre><code>const replacedCount = docOps.replaceDocumentByQuery(\n  { status: 'pending' },\n  { status: 'approved', approvedBy: 'admin' }\n);\nconsole.log(`${replacedCount} document(s) replaced.`);\n</code></pre>"},{"location":"developers/Collection_Components/#private-methods","title":"Private Methods","text":"<p><code>DocumentOperations</code> includes several private helper methods for validation, ID generation, and query orchestration:</p> <p>Validation &amp; ID Generation:</p> <ul> <li><code>_generateDocumentId()</code>: Generates a unique ID for new documents.</li> <li><code>_validateDocument(doc)</code>: Validates the overall document structure and content.</li> <li><code>_validateDocumentId(id)</code>: Validates a standalone document ID.</li> <li><code>_validateDocumentIdInDocument(id, doc)</code>: Validates an <code>_id</code> field within a document.</li> <li><code>_validateDocumentFields(doc)</code>: Validates field names within a document.</li> <li><code>_checkDuplicateId(id)</code>: Ensures an <code>_id</code> is not already in use before insertion.</li> <li><code>_validateQuery(query)</code>: Basic validation for query objects.</li> <li><code>_validateUpdateOperators(updateOps)</code>: Basic validation for update operator objects.</li> </ul> <p>Query Execution (D1 Refactoring):</p> <ul> <li><code>_executeQuery(query, operation)</code>: Consolidates query validation, document retrieval, QueryEngine execution, and logging. Used by <code>findByQuery()</code>, <code>findMultipleByQuery()</code>, and <code>countByQuery()</code>.</li> </ul> <p>Bulk Operations (D2 Refactoring):</p> <ul> <li><code>_applyToMatchingDocuments(query, applyFn, throwIfNoMatches)</code>: Unifies match/apply pattern for query-based bulk operations. Finds matching documents, applies callback function, and accumulates affected count. Used by <code>updateDocumentByQuery()</code> and <code>replaceDocumentByQuery()</code>.</li> </ul> <p>These private methods ensure data integrity, consistent error handling, and DRY principles within the component.</p>"},{"location":"developers/Database/","title":"Database Developer Documentation","text":"<ul> <li>Database Developer Documentation</li> <li>Overview</li> <li>Architecture \\&amp; MasterIndex Integration<ul> <li>Refactored Design (Single Source of Truth)</li> <li>Data Sources</li> <li>Collection Access Protocol</li> </ul> </li> <li>Database Initialization and Recovery Workflow<ul> <li>First-Time Setup</li> <li>Normal Initialization</li> <li>Disaster Recovery</li> <li>Benefits of New Workflow</li> </ul> </li> <li>Constructor</li> <li>API Reference<ul> <li>Core Methods</li> <li><code>createDatabase()</code></li> <li><code>initialise()</code></li> <li><code>recoverDatabase(backupFileId)</code></li> <li><code>getCollection(name)</code></li> <li><code>createCollection(name)</code></li> <li><code>listCollections()</code></li> <li><code>dropCollection(name)</code></li> <li><code>loadIndex()</code></li> <li><code>backupIndexToDrive()</code></li> <li>Private Methods</li> <li><code>_findExistingIndexFile()</code></li> <li><code>_createIndexFile()</code></li> <li><code>ensureIndexFile()</code></li> <li><code>_resolveCollection(resolvedName, originalName)</code></li> <li><code>_createCollectionObject(name, driveFileId)</code></li> <li><code>_normaliseIndexData(rawData)</code></li> <li><code>_assertIndexObject(indexCandidate)</code></li> <li><code>_ensureCollectionsMap(indexData)</code></li> <li><code>_ensureLastUpdated(indexData)</code></li> <li><code>_validateCollectionName(name)</code></li> </ul> </li> <li>Usage Examples<ul> <li>Basic Database Setup</li> <li>Collection Management</li> <li>Index File Operations</li> <li>Error Handling</li> </ul> </li> <li>Integration with MasterIndex<ul> <li>Collection Lifecycle</li> <li>Data Synchronization</li> <li>Backup Strategy</li> </ul> </li> <li>Error Types</li> <li>Best Practices</li> </ul>"},{"location":"developers/Database/#overview","title":"Overview","text":"<p>The <code>Database</code> class is the main entry point for GAS DB operations, providing high-level database management and collection coordination. It serves as an orchestrator that delegates collection metadata management to <code>MasterIndex</code> while maintaining Drive-based index files for backup and migration purposes.</p> <p>Key Responsibilities:</p> <ul> <li>Database creation, initialization, and recovery</li> <li>Collection creation, access, and deletion</li> <li>MasterIndex as single source of truth for metadata</li> <li>Drive index file backup operations</li> <li>High-level database operations and error handling</li> </ul> <p>Dependencies:</p> <ul> <li><code>MasterIndex</code>: Single source of truth for collection metadata</li> <li><code>FileService</code>: Drive API operations and caching</li> <li><code>DatabaseConfig</code>: Configuration management</li> <li><code>JDbLogger</code>: Logging and monitoring</li> </ul>"},{"location":"developers/Database/#architecture-masterindex-integration","title":"Architecture &amp; MasterIndex Integration","text":""},{"location":"developers/Database/#refactored-design-single-source-of-truth","title":"Refactored Design (Single Source of Truth)","text":"<p>Following the initialization refactoring, the Database class now enforces MasterIndex as the single source of truth:</p> <pre><code>Database (Orchestrator)\n\u251c\u2500\u2500 MasterIndex (Single source of truth - ScriptProperties)\n\u251c\u2500\u2500 Drive Index File (Backup only)\n\u251c\u2500\u2500 FileService (Drive operations)\n\u2514\u2500\u2500 Collections Map (In-memory cache)\n</code></pre>"},{"location":"developers/Database/#data-sources","title":"Data Sources","text":"<p>Single Source of Truth - MasterIndex:</p> <ul> <li>Fast access via ScriptProperties</li> <li>Authoritative for all collection metadata</li> <li>Virtual locking and conflict detection</li> <li>Cross-instance coordination</li> <li>Used for all normal operations</li> </ul> <p>Backup Only - Drive Index File:</p> <ul> <li>Backup and durability</li> <li>Migration and recovery scenarios</li> <li>Explicit synchronization via <code>backupIndexToDrive()</code></li> </ul>"},{"location":"developers/Database/#collection-access-protocol","title":"Collection Access Protocol","text":"<p>UPDATED: The <code>getCollection()</code> method validates the caller input, logs any sanitisation, and delegates to the shared <code>_resolveCollection(resolvedName, originalName)</code> helper for consistent caching and error messaging. (Note: The <code>collection()</code> alias was removed in v0.0.5.)</p> <ol> <li>Public method sanitises and validate the name up front, logging when characters were stripped while keeping the unsanitised input for messaging</li> <li><code>_resolveCollection()</code> checks the in-memory collections cache using the sanitised key</li> <li>If not cached, the helper queries MasterIndex (single source of truth)</li> <li>When the collection is still missing, <code>_resolveCollection()</code> auto-creates if permitted, otherwise it raises an error that includes the caller\u2019s original name</li> </ol> <p>Important: <code>_resolveCollection()</code> ensures the caller sees the original name in error messages when auto-create is disabled, even if sanitisation adjusted the lookup key. The helper also short-circuits when the configuration forbids auto-creation</p> <p>You can tune the behaviour by enabling <code>stripDisallowedCollectionNameCharacters</code> on <code>DatabaseConfig</code>. When enabled, the sanitised name is the one persisted in caches and the MasterIndex, yet <code>_resolveCollection()</code> keeps the unsanitised input for messaging parity so developers can reconcile errors with their original call site.</p>"},{"location":"developers/Database/#database-initialization-and-recovery-workflow","title":"Database Initialization and Recovery Workflow","text":"<p>NEW: The Database class now enforces a clear separation between creation, initialization, and recovery:</p>"},{"location":"developers/Database/#first-time-setup","title":"First-Time Setup","text":"<p>Using the public API (recommended for Apps Script library consumers):</p> <pre><code>const db = JsonDbApp.createAndInitialiseDatabase(config); // Creates MasterIndex + initialises\n</code></pre> <p>Or using the class directly (within this project):</p> <pre><code>const db = new Database(config);\ndb.createDatabase();\ndb.initialise();\n</code></pre>"},{"location":"developers/Database/#normal-initialization","title":"Normal Initialization","text":"<p>Using the public API:</p> <pre><code>const db = JsonDbApp.loadDatabase(config); // initialises from existing MasterIndex\n</code></pre> <p>Or directly:</p> <pre><code>const db = new Database(config);\ndb.initialise();\n</code></pre>"},{"location":"developers/Database/#disaster-recovery","title":"Disaster Recovery","text":"<pre><code>const db = new Database(config);\ndb.recoverDatabase(backupFileId); // Restores from backup to MasterIndex\ndb.initialise(); // Loads from restored MasterIndex\n</code></pre>"},{"location":"developers/Database/#benefits-of-new-workflow","title":"Benefits of New Workflow","text":"<ul> <li>Single Source of Truth: MasterIndex is the authoritative source, eliminating race conditions</li> <li>Clear Separation: Distinct operations for creation, initialization, and recovery</li> <li>Fail-Fast: Explicit errors when MasterIndex is missing or corrupted</li> <li>Simplified Operations: No dual-source complexity in collection methods</li> </ul>"},{"location":"developers/Database/#constructor","title":"Constructor","text":"<pre><code>class Database {\n  constructor(config = {}) {\n    // ...\n  }\n}\n</code></pre> <p>Parameters:</p> <ul> <li><code>config</code> (Object|DatabaseConfig): Database configuration object or DatabaseConfig instance</li> </ul> <p>Behaviour:</p> <ul> <li>Validates and normalizes configuration via DatabaseConfig</li> <li>initialises logging, file services, and MasterIndex</li> <li>Creates in-memory collections map</li> <li>Does NOT automatically initialise - call <code>initialise()</code> explicitly</li> </ul> <p>Example:</p> <pre><code>const db = new Database({\n  rootFolderId: 'your-folder-id',\n  autoCreateCollections: true,\n  logLevel: 'DEBUG'\n});\n</code></pre>"},{"location":"developers/Database/#api-reference","title":"API Reference","text":""},{"location":"developers/Database/#core-methods","title":"Core Methods","text":""},{"location":"developers/Database/#createdatabase","title":"<code>createDatabase()</code>","text":"<p>NEW: Creates a new database for first-time setup.</p> <ul> <li>Returns: <code>void</code></li> <li>Throws: <code>Error</code> when MasterIndex already exists or creation fails</li> <li>Use Cases:</li> <li>First-time database setup</li> <li>Clean database creation for new projects</li> </ul> <p>Process:</p> <ol> <li>Check if MasterIndex already exists in ScriptProperties</li> <li>If exists, throw error directing user to recovery process</li> <li>Create fresh MasterIndex with empty collections</li> <li>Persist to ScriptProperties</li> </ol>"},{"location":"developers/Database/#initialise","title":"<code>initialise()</code>","text":"<p>REFACTORED: initialises the database from MasterIndex only (single source of truth).</p> <ul> <li>Returns: <code>void</code></li> <li>Throws: <code>Error</code> when MasterIndex is missing, corrupted, or initialization fails</li> <li>Side Effects:</li> <li>Loads collections from MasterIndex into memory</li> <li>When <code>backupOnInitialise</code> is <code>true</code>, ensures a Drive-based index file exists for backups</li> <li>When <code>backupOnInitialise</code> is <code>true</code>, backs up the MasterIndex to the Drive index file</li> </ul> <p>Process:</p> <ol> <li>Verify MasterIndex exists and is valid</li> <li>Load existing collections from MasterIndex (single source of truth)</li> <li>When <code>backupOnInitialise</code> is <code>true</code>, create or find the Drive-based index file used for backups</li> <li>When <code>backupOnInitialise</code> is <code>true</code> and collections exist, back up the MasterIndex to the Drive index file</li> <li>Populate in-memory collections cache</li> </ol> <p>Important: No longer falls back to Drive index file. If MasterIndex is missing or corrupted, use <code>createDatabase()</code> for fresh setup or <code>recoverDatabase()</code> for recovery.</p>"},{"location":"developers/Database/#recoverdatabasebackupfileid","title":"<code>recoverDatabase(backupFileId)</code>","text":"<p>NEW: Recovers database from a backup index file.</p> <ul> <li>Parameters:</li> <li><code>backupFileId</code> (String): Drive file ID of backup index file</li> <li>Returns: <code>Array&lt;String&gt;</code> - Names of recovered collections</li> <li>Throws: <code>Error</code> when recovery fails or backup file is invalid</li> <li>Use Cases:</li> <li>Disaster recovery when MasterIndex is lost or corrupted</li> <li>Migration from old backup files</li> <li>Data restoration scenarios</li> </ul> <p>Process:</p> <ol> <li>Load and validate backup index file structure</li> <li>Create fresh MasterIndex for recovery</li> <li>Restore collections from backup to MasterIndex</li> <li>Persist restored MasterIndex to ScriptProperties</li> </ol>"},{"location":"developers/Database/#getcollectionname","title":"<code>getCollection(name)</code>","text":"<p>UPDATED: Gets or creates a collection (MasterIndex only).</p> <ul> <li>Parameters:</li> <li><code>name</code> (String): Collection name</li> <li>Returns: <code>Object</code> - Collection object</li> <li>Throws: <code>Error</code> for invalid names or when collection doesn't exist and auto-create is disabled</li> </ul> <p>Access Path:</p> <ol> <li>Public method sanitises and validates the name, logging adjustments</li> <li><code>_resolveCollection()</code> uses the sanitised name for cache and MasterIndex lookups</li> <li>Cache hit returns immediately; otherwise MasterIndex metadata is used to build the collection</li> <li>Auto-create (if enabled) creates the collection before returning; when disabled the helper throws with the caller's original name</li> </ol> <p>Important:</p> <ul> <li>No longer falls back to Drive index file</li> <li>When auto-create is disabled, <code>_resolveCollection()</code> raises an error that includes the caller's original name</li> <li>The <code>collection()</code> alias was removed in v0.0.5 - use <code>getCollection()</code> as the canonical method</li> </ul>"},{"location":"developers/Database/#createcollectionname","title":"<code>createCollection(name)</code>","text":"<p>Explicitly creates a new collection.</p> <ul> <li>Parameters:</li> <li><code>name</code> (String): Collection name</li> <li>Returns: <code>Object</code> - Created collection object</li> <li>Throws: <code>Error</code> for invalid names or if collection already exists</li> </ul> <p>Process:</p> <ol> <li>Validate collection name</li> <li>Check for existing collection in MasterIndex and memory</li> <li>Create Drive file with initial collection data</li> <li>Add to MasterIndex (primary)</li> <li>Add to Drive index file (backup)</li> <li>Add to in-memory cache</li> </ol>"},{"location":"developers/Database/#listcollections","title":"<code>listCollections()</code>","text":"<p>UPDATED: Lists all collection names from MasterIndex only.</p> <ul> <li>Returns: <code>Array&lt;String&gt;</code> - Collection names</li> <li>Data Source: MasterIndex (single source of truth)</li> </ul> <p>Important: No longer falls back to Drive index file.</p>"},{"location":"developers/Database/#dropcollectionname","title":"<code>dropCollection(name)</code>","text":"<p>UPDATED: Deletes a collection and its data (MasterIndex only).</p> <ul> <li>Parameters:</li> <li><code>name</code> (String): Collection name to delete</li> <li>Returns: <code>Boolean</code> - Success status</li> <li>Throws: <code>Error</code> for invalid collection names</li> </ul> <p>Process:</p> <ol> <li>Find collection in MasterIndex (single source of truth)</li> <li>Delete collection Drive file</li> <li>Remove from in-memory cache</li> <li>Remove from MasterIndex</li> <li>Remove from Drive index file (backup updates occur only when Drive backups are enabled)</li> </ol> <p>Important: No longer falls back to Drive index file.</p>"},{"location":"developers/Database/#loadindex","title":"<code>loadIndex()</code>","text":"<p>Loads and validates Drive-based index file data.</p> <ul> <li>Returns: <code>Object</code> - Index file data with structure validation</li> <li>Throws: <code>ErrorHandler.ErrorTypes.INVALID_FILE_FORMAT</code> for corrupted or structurally invalid payloads, <code>ErrorHandler.ErrorTypes.FILE_IO_ERROR</code> when Drive reads fail</li> </ul> <p>Validation &amp; Repair:</p> <ul> <li><code>_normaliseIndexData()</code> ensures the parsed value is an object, applying default envelopes and surfacing <code>INVALID_FILE_FORMAT</code> errors when validation fails</li> <li><code>_assertIndexObject()</code> rejects malformed payloads (including top-level arrays) using <code>ErrorHandler.ErrorTypes.INVALID_FILE_FORMAT</code></li> <li><code>_ensureCollectionsMap()</code> guarantees <code>collections</code> is a map, repairing missing entries and raising <code>INVALID_FILE_FORMAT</code> when an existing value has the wrong type</li> <li><code>_ensureLastUpdated()</code> backfills timestamps when absent</li> </ul> <p>These helpers are also used by index mutation utilities so that validation and repair logic remains centralised. Before reading the Drive index file, <code>loadIndex()</code> calls <code>ensureIndexFile()</code> so the file is only created or touched when backups are enabled (<code>backupOnInitialise: true</code>) or when an explicit index operation needs it.</p> <p>Regression suites cover array payload rejection and timestamp preservation so that future changes retain these guarantees.</p>"},{"location":"developers/Database/#backupindextodrive","title":"<code>backupIndexToDrive()</code>","text":"<p>Explicitly backs up MasterIndex data to Drive-based index file.</p> <ul> <li>Returns: <code>Boolean</code> - Success status</li> <li>Use Cases:</li> <li>Periodic backups</li> <li>Before major operations</li> <li>Data migration scenarios</li> </ul>"},{"location":"developers/Database/#private-methods","title":"Private Methods","text":""},{"location":"developers/Database/#_findexistingindexfile","title":"<code>_findExistingIndexFile()</code>","text":"<p>Searches root folder for existing database index files.</p> <ul> <li>Returns: <code>String|null</code> - File ID if found</li> <li>Search Pattern: Files containing 'database_index' and ending with '.json'</li> </ul>"},{"location":"developers/Database/#_createindexfile","title":"<code>_createIndexFile()</code>","text":"<p>Creates a new Drive-based index file with initial structure.</p> <ul> <li>Side Effects: Sets <code>this.indexFileId</code></li> <li>Initial Structure: Empty collections, timestamps, version</li> </ul>"},{"location":"developers/Database/#ensureindexfile","title":"<code>ensureIndexFile()</code>","text":"<p>Lazily locates or creates the Drive-based index file. This helper is invoked when <code>backupOnInitialise</code> is <code>true</code> during <code>initialise()</code> and before any other Drive index operations so unnecessary Drive writes are avoided when backups are disabled.</p>"},{"location":"developers/Database/#_resolvecollectionresolvedname-originalname","title":"<code>_resolveCollection(resolvedName, originalName)</code>","text":"<p>Centralises collection resolution for <code>getCollection()</code> after the public wrapper sanitises the input.</p> <ul> <li>Parameters:</li> <li><code>resolvedName</code> (String): Sanitised collection name used for cache and MasterIndex lookups</li> <li><code>originalName</code> (String): Caller-supplied name used for error messaging and auto-create delegations</li> <li>Returns: <code>Object</code> - Collection object from cache or newly constructed via MasterIndex metadata</li> <li>Behaviour:</li> <li>Checks cache before contacting MasterIndex</li> <li>Rehydrates a collection using MasterIndex metadata when available</li> <li>Throws with the original caller input when auto-create is disabled and the collection is missing</li> <li>Creates and caches new collections (via <code>createCollection(originalName)</code>) when auto-create is permitted</li> </ul>"},{"location":"developers/Database/#_buildcollectionmetadatapayloadname-fileid-documentcount-0-new-in-v005","title":"<code>_buildCollectionMetadataPayload(name, fileId, documentCount = 0)</code> \u2b50 NEW in v0.0.5","text":"<p>Added in: DB3 refactoring</p> <p>Centralized helper for constructing collection metadata payloads with consistent field structure.</p> <ul> <li>Parameters:</li> <li><code>name</code> (String): Collection name</li> <li><code>fileId</code> (String): Drive file ID for the collection</li> <li><code>documentCount</code> (Number): Initial document count (default: 0)</li> <li>Returns: <code>Object</code> - Metadata payload with standardized fields</li> <li>Structure: <pre><code>{\n  name: name,\n  fileId: fileId,\n  created: new Date(),\n  lastUpdated: new Date(),\n  documentCount: documentCount\n}\n</code></pre></li> <li>Usage: Used by <code>addCollectionToMasterIndex()</code>, <code>addCollectionToIndex()</code>, <code>_restoreCollectionFromBackup()</code>, and collection management operations</li> <li>Benefits: Single source of truth for metadata structure, guaranteed field alignment</li> </ul>"},{"location":"developers/Database/#_wrapmasterindexerroroperation-error-messageprefix-new-in-v005","title":"<code>_wrapMasterIndexError(operation, error, messagePrefix)</code> \u2b50 NEW in v0.0.5","text":"<p>Added in: DB2 refactoring</p> <p>Wraps non-GASDB errors into MasterIndexError with consistent formatting.</p> <ul> <li>Parameters:</li> <li><code>operation</code> (String): Operation identifier for error context</li> <li><code>error</code> (Error): Original error to wrap</li> <li><code>messagePrefix</code> (String): Prefix for error message</li> <li>Returns: <code>Error</code> - Original GASDB error or new MasterIndexError</li> <li>Behaviour:</li> <li>Returns error unchanged if already a GASDB_ERROR</li> <li>Creates new MASTER_INDEX_ERROR for non-GASDB errors</li> <li>Formats message as: <code>${messagePrefix}: ${error.message}</code></li> <li>Usage: Used by <code>createDatabase()</code>, <code>initialise()</code>, <code>recoverDatabase()</code></li> <li>Benefits: Consistent error wrapping, preserves error types for tests</li> </ul>"},{"location":"developers/Database/#_createcollectionobjectname-drivefileid","title":"<code>_createCollectionObject(name, driveFileId)</code>","text":"<p>Creates a minimal collection object (placeholder for full Collection class).</p> <ul> <li>Parameters:</li> <li><code>name</code> (String): Collection name</li> <li><code>driveFileId</code> (String): Drive file ID</li> <li>Returns: <code>Object</code> - Collection object</li> <li>Note: Currently returns minimal object; will integrate with full Collection class in Section 5</li> </ul>"},{"location":"developers/Database/#_normaliseindexdatarawdata","title":"<code>_normaliseIndexData(rawData)</code>","text":"<p>Prepares parsed index content for validation and repair.</p> <ul> <li>Parameters:</li> <li><code>rawData</code> (any): Value returned by <code>JSON.parse</code></li> <li>Behaviour:</li> <li>Delegates to <code>_assertIndexObject()</code> to reject anything other than a plain object whilst expecting callers to supply an object-shaped payload</li> <li>Does not coerce primitives, arrays, or <code>null</code> into objects; it simply verifies the input already meets the contract</li> <li>Ensures the collections map and <code>lastUpdated</code> timestamp exist by calling <code>_ensureCollectionsMap()</code> and <code>_ensureLastUpdated()</code></li> <li>Returns the original object reference so callers persist a repaired but familiar structure</li> </ul>"},{"location":"developers/Database/#_assertindexobjectindexcandidate","title":"<code>_assertIndexObject(indexCandidate)</code>","text":"<p>Guarantees the index payload has an object shape.</p> <ul> <li>Parameters:</li> <li><code>indexCandidate</code> (any): Value from <code>_normaliseIndexData()</code></li> <li>Throws: <code>ErrorHandler.ErrorTypes.INVALID_FILE_FORMAT</code> when the payload is not a plain object (rejects arrays, primitives, <code>null</code>, dates, etc.)</li> <li>Behaviour:</li> <li>Rejects unsupported payloads early so Drive corruption surfaces immediately</li> <li>Returns the candidate unchanged when it is a plain object</li> </ul>"},{"location":"developers/Database/#_ensurecollectionsmapindexdata","title":"<code>_ensureCollectionsMap(indexData)</code>","text":"<p>Ensures <code>collections</code> exists and has the expected type.</p> <ul> <li>Parameters:</li> <li><code>indexData</code> (Object): Index data returned by <code>_assertIndexObject()</code></li> <li>Behaviour:</li> <li>Repairs a missing <code>collections</code> property by seeding an empty map</li> <li>Throws <code>ErrorHandler.ErrorTypes.INVALID_FILE_FORMAT</code> when an existing <code>collections</code> value is not an object map</li> <li>Preserves valid maps so timestamp comparisons remain stable</li> </ul>"},{"location":"developers/Database/#_ensurelastupdatedindexdata","title":"<code>_ensureLastUpdated(indexData)</code>","text":"<p>Ensures the index metadata has a <code>lastUpdated</code> timestamp.</p> <ul> <li>Parameters:</li> <li><code>indexData</code> (Object): Index object returned by <code>_assertIndexObject()</code></li> <li>Behaviour:</li> <li>Adds a timestamp when missing or invalid</li> <li>Keeps existing timestamps intact so tests can assert stability</li> </ul>"},{"location":"developers/Database/#_validatecollectionnamename","title":"<code>_validateCollectionName(name)</code>","text":"<p>Validates collection name according to GAS DB rules.</p> <ul> <li>Parameters:</li> <li><code>name</code> (String): Name to validate</li> <li>Throws: <code>Error</code> for invalid names</li> <li>Rules:</li> <li>Must be non-empty string</li> <li>No invalid filesystem characters (<code>[\\/\\\\:*?\"&lt;&gt;|]</code>). When <code>stripDisallowedCollectionNameCharacters</code> is enabled on the configuration, the characters are removed before the checks below, and any modification is logged for diagnostics.</li> <li>Not reserved names (index, master, system, admin). The reserved-name check is applied after sanitisation so <code>index/</code> will still be rejected even though the slash is removed.</li> </ul>"},{"location":"developers/Database/#usage-examples","title":"Usage Examples","text":""},{"location":"developers/Database/#basic-database-setup","title":"Basic Database Setup","text":"<pre><code>const config = new DatabaseConfig({\n  rootFolderId: 'your-drive-folder-id',\n  autoCreateCollections: true,\n  logLevel: 'INFO'\n});\n\nconst db = new Database(config);\nawait db.initialise();\n\nconsole.log('Available collections:', db.listCollections());\n</code></pre>"},{"location":"developers/Database/#collection-management","title":"Collection Management","text":"<pre><code>// Create collection explicitly\nconst users = db.createCollection('users');\n\n// Get existing collection (or auto-create if enabled)\nconst posts = db.getCollection('posts');\n\n// List all collections\nconst allCollections = db.listCollections();\nconsole.log('Collections:', allCollections);\n\n// Drop collection\nconst success = db.dropCollection('temp_collection');\n</code></pre>"},{"location":"developers/Database/#index-file-operations","title":"Index File Operations","text":"<pre><code>// Load index file data\ntry {\n  const indexData = db.loadIndex();\n  console.log('Index contains:', Object.keys(indexData.collections));\n} catch (error) {\n  console.error('Index file corrupted:', error.message);\n}\n\n// Backup MasterIndex to Drive\nconst backupSuccess = db.backupIndexToDrive();\nif (backupSuccess) {\n  console.log('Backup completed successfully');\n}\n</code></pre>"},{"location":"developers/Database/#error-handling","title":"Error Handling","text":"<pre><code>try {\n  const collection = db.getCollection('invalid/name');\n} catch (error) {\n  if (error.message.includes('invalid characters')) {\n    console.error('Collection name validation failed');\n  }\n}\n\n// Handle initialization errors\ntry {\n  db.initialise();\n} catch (error) {\n  console.error('Database initialization failed:', error.message);\n  // Implement recovery logic\n}\n</code></pre>"},{"location":"developers/Database/#integration-with-masterindex","title":"Integration with MasterIndex","text":""},{"location":"developers/Database/#collection-lifecycle","title":"Collection Lifecycle","text":"<pre><code>// Collection Creation Flow\ndb.createCollection('users');\n// 1. Validate name\n// 2. Create Drive file\n// 3. Add to MasterIndex (primary)\n// 4. Add to Drive index (backup)\n// 5. Cache in memory\n</code></pre>"},{"location":"developers/Database/#data-synchronization","title":"Data Synchronization","text":"<p>The Database class maintains consistency between data sources:</p> <ul> <li>MasterIndex \u2192 Memory: On initialization and collection access</li> <li>Index File \u2192 MasterIndex: When collections found only in index file</li> <li>MasterIndex \u2192 Index File: Via explicit <code>backupIndexToDrive()</code></li> </ul>"},{"location":"developers/Database/#backup-strategy","title":"Backup Strategy","text":"<pre><code>// Periodic backup pattern\nsetInterval(\n  () =&gt; {\n    if (db.backupIndexToDrive()) {\n      console.log('Periodic backup completed');\n    }\n  },\n  30 * 60 * 1000\n); // Every 30 minutes\n</code></pre>"},{"location":"developers/Database/#error-types","title":"Error Types","text":"<ul> <li>Invalid Configuration: Configuration validation failures</li> <li>Collection Name Validation: Invalid characters or reserved names</li> <li>Collection Already Exists: Duplicate collection creation</li> <li>Collection Not Found: Accessing non-existent collections</li> <li>Index File Corruption: JSON parsing or structure validation errors</li> <li>Drive API Errors: File operation failures</li> <li>Initialization Errors: Database setup failures</li> </ul>"},{"location":"developers/Database/#best-practices","title":"Best Practices","text":"<ol> <li>Always initialise explicitly: Call <code>initialise()</code> after constructor</li> <li>Handle collection name validation: Use try-catch for collection operations</li> <li>Implement periodic backups: Use <code>backupIndexToDrive()</code> regularly</li> <li>Monitor index file health: Check for corruption and implement recovery</li> <li>Use proper error handling: Different error types require different recovery strategies</li> <li>Leverage auto-create judiciously: Enable for development, consider disabling for production</li> <li>Cache collection references: Store collection objects to avoid repeated lookups</li> <li>Clean up properly: Use <code>dropCollection()</code> to remove unused collections</li> </ol>"},{"location":"developers/DatabaseConfig/","title":"DatabaseConfig Developer Documentation","text":"<ul> <li>DatabaseConfig Developer Documentation</li> <li>Overview</li> <li>Constants</li> <li>Configuration Properties<ul> <li>Core Properties</li> <li>Optional Properties</li> </ul> </li> <li>Constructor</li> <li>API Reference<ul> <li>Public Methods</li> <li><code>clone()</code></li> <li><code>toJSON()</code></li> <li><code>fromJSON(obj)</code></li> <li>Private Methods</li> <li><code>_initialiseGeneralDefaults(config)</code></li> <li><code>_initialiseRetryConfig(config)</code></li> <li><code>_initialiseQueryEngineConfig(config)</code></li> <li><code>_initialiseBooleanFlags(config)</code></li> <li><code>_getDefaultRootFolder()</code></li> <li><code>_validateConfig()</code></li> <li><code>_validateQueryOperators()</code></li> <li><code>_validateOperatorArray(configKey, operators, rawValue, wasProvided)</code></li> </ul> </li> <li>Validation Rules<ul> <li>Property Validation</li> <li>Error Scenarios</li> </ul> </li> <li>Usage Examples<ul> <li>Basic Configuration</li> <li>Development vs Production</li> <li>Configuration Cloning</li> <li>Configuration Serialization</li> </ul> </li> <li>Integration with Database</li> <li>Component-Level Configuration<ul> <li>QueryEngine Configuration</li> <li>FileOperations Configuration</li> <li>Index Backup Strategy</li> </ul> </li> <li>Best Practices</li> </ul>"},{"location":"developers/DatabaseConfig/#overview","title":"Overview","text":"<p>The <code>DatabaseConfig</code> class manages database configuration settings with validation and defaults. It provides a standardized configuration object for Database instances, ensuring all settings are validated and properly formatted before use.</p> <p>Key Responsibilities:</p> <ul> <li>Configuration validation and normalization</li> <li>Default value management</li> <li>Type checking and constraint enforcement</li> <li>Configuration cloning and serialization</li> </ul> <p>Design Principles:</p> <ul> <li>Fail-fast validation in constructor</li> <li>Configuration intended to be treated as immutable after creation</li> <li>Clear error messages for invalid settings</li> <li>Sensible defaults for all properties</li> </ul>"},{"location":"developers/DatabaseConfig/#constants","title":"Constants","text":"<p><code>DatabaseConfig</code> internally defines shared constants for log handling so the configuration stays in sync with <code>JDbLogger</code> behaviour. These are implementation details used for validation and are not exposed as public static properties or part of the public API:</p> <ul> <li><code>LOG_LEVELS</code>: ordered array of accepted level names (<code>['DEBUG','INFO','WARN','ERROR']</code>) used during validation.</li> <li><code>DEFAULT_LOG_LEVEL</code>: default value (<code>'INFO'</code>) applied when no explicit level is supplied.</li> </ul>"},{"location":"developers/DatabaseConfig/#configuration-properties","title":"Configuration Properties","text":""},{"location":"developers/DatabaseConfig/#core-properties","title":"Core Properties","text":"Property Type Default Description <code>rootFolderId</code> String Drive root folder Root Drive folder for database files <code>masterIndexKey</code> String 'GASDB_MASTER_INDEX' ScriptProperties key for master index"},{"location":"developers/DatabaseConfig/#optional-properties","title":"Optional Properties","text":"Property Type Default Description <code>autoCreateCollections</code> Boolean <code>true</code> Auto-create collections when accessed <code>lockTimeout</code> Number <code>30000</code> Lock timeout in milliseconds <code>retryAttempts</code> Number <code>3</code> Lock acquisition retry attempts <code>retryDelayMs</code> Number <code>1000</code> Delay between lock retries <code>lockRetryBackoffBase</code> Number <code>2</code> Exponential backoff base for lock retries <code>cacheEnabled</code> Boolean <code>true</code> Enable file caching <code>logLevel</code> String <code>DEFAULT_LOG_LEVEL</code> ('INFO') Log level constrained to the values declared in <code>LOG_LEVELS</code> <code>fileRetryAttempts</code> Number <code>3</code> File operation retry attempts <code>fileRetryDelayMs</code> Number <code>1000</code> Delay between file retries <code>fileRetryBackoffBase</code> Number <code>2</code> Exponential backoff base for file retries <code>queryEngineMaxNestedDepth</code> Number <code>10</code> Maximum allowed query nesting depth <code>queryEngineSupportedOperators</code> String[] <code>['$eq','$gt','$lt','$and','$or']</code> Operators permitted by the QueryEngine <code>queryEngineLogicalOperators</code> String[] <code>['$and','$or']</code> Logical operators recognised by the QueryEngine <code>backupOnInitialise</code> Boolean <code>false</code> If true, <code>Database.initialise()</code> will create/find the Drive index file and back up the MasterIndex immediately. If false, the backup index is created lazily on first write (e.g. creating/dropping a collection) or when <code>loadIndex()</code> is called. <code>stripDisallowedCollectionNameCharacters</code> Boolean <code>false</code> When enabled, invalid characters are stripped from collection names before validation so integrations that cannot guarantee clean inputs can still rely on strict reserved-name and empty-name checks."},{"location":"developers/DatabaseConfig/#constructor","title":"Constructor","text":"<pre><code>class DatabaseConfig {\n  constructor(config = {}) {\n    // ...\n  }\n}\n</code></pre> <p>Parameters:</p> <ul> <li><code>config</code> (Object): Configuration options object</li> </ul> <p>Behaviour:</p> <ul> <li>Delegates to grouped helpers (<code>_initialiseGeneralDefaults</code>, <code>_initialiseRetryConfig</code>, <code>_initialiseQueryEngineConfig</code>, <code>_initialiseBooleanFlags</code>) so each concern applies defaults consistently.</li> <li>Uses nullish coalescing (<code>??</code>) to normalise nullish overrides while keeping explicit falsy values intact.</li> <li>Sets default values for all properties</li> <li>Validates all configuration parameters</li> <li>Throws errors immediately for invalid settings</li> <li>Automatically determines root folder if not provided</li> </ul> <p>Example:</p> <pre><code>const config = new DatabaseConfig({\n  rootFolderId: 'your-folder-id',\n  autoCreateCollections: false,\n  logLevel: 'DEBUG'\n});\n</code></pre>"},{"location":"developers/DatabaseConfig/#api-reference","title":"API Reference","text":""},{"location":"developers/DatabaseConfig/#public-methods","title":"Public Methods","text":""},{"location":"developers/DatabaseConfig/#clone","title":"<code>clone()</code>","text":"<p>Creates a deep copy of the configuration.</p> <ul> <li>Returns: <code>DatabaseConfig</code> - New configuration instance</li> <li>Use Cases:</li> <li>Creating modified configurations</li> <li>Immutable configuration management</li> <li>Testing with variations</li> </ul>"},{"location":"developers/DatabaseConfig/#tojson","title":"<code>toJSON()</code>","text":"<p>Converts configuration to a serialisable plain object with a <code>__type</code> tag.</p> <ul> <li>Returns: <code>Object</code> - Plain object suitable for JSON serialisation</li> <li>Use Cases:</li> <li>Serialisation</li> <li>Debugging and logging</li> <li>Configuration comparison</li> </ul>"},{"location":"developers/DatabaseConfig/#fromjsonobj","title":"<code>fromJSON(obj)</code>","text":"<p>Creates a <code>DatabaseConfig</code> from an object produced by <code>toJSON()</code>.</p> <ul> <li>Parameters: <code>obj</code> (<code>Object</code>) - A deserialised config object containing <code>__type: 'DatabaseConfig'</code></li> <li>Returns: <code>DatabaseConfig</code></li> <li>Throws: <code>InvalidArgumentError</code> if the object is not a valid <code>DatabaseConfig</code> serialisation</li> </ul>"},{"location":"developers/DatabaseConfig/#private-methods","title":"Private Methods","text":""},{"location":"developers/DatabaseConfig/#_initialisegeneraldefaultsconfig","title":"<code>_initialiseGeneralDefaults(config)</code>","text":"<p>Applies root folder, lock timeout, log level (via <code>DEFAULT_LOG_LEVEL</code>), and master index defaults.</p>"},{"location":"developers/DatabaseConfig/#_initialiseretryconfigconfig","title":"<code>_initialiseRetryConfig(config)</code>","text":"<p>Normalises retry-related options (lock and file retries) with grouped defaults.</p>"},{"location":"developers/DatabaseConfig/#_initialisequeryengineconfigconfig","title":"<code>_initialiseQueryEngineConfig(config)</code>","text":"<p>Clones provided operator arrays when supplied and records raw values for validation while restoring defaults when omitted.</p>"},{"location":"developers/DatabaseConfig/#_initialisebooleanflagsconfig","title":"<code>_initialiseBooleanFlags(config)</code>","text":"<p>Initialises boolean feature toggles such as <code>autoCreateCollections</code> and <code>backupOnInitialise</code>.</p>"},{"location":"developers/DatabaseConfig/#_getdefaultrootfolder","title":"<code>_getDefaultRootFolder()</code>","text":"<p>Determines the default root folder ID.</p> <ul> <li>Returns: <code>String</code> - Drive root folder ID</li> <li>Throws: <code>Error</code> if unable to access Drive</li> <li>Behaviour: Uses <code>DriveApp.getRootFolder().getId()</code></li> </ul>"},{"location":"developers/DatabaseConfig/#_validateconfig","title":"<code>_validateConfig()</code>","text":"<p>Validates all configuration properties according to rules.</p> <ul> <li>Throws: <code>Error</code> for any validation failure</li> <li>Validation Order:</li> <li>Type checking</li> <li>Range validation</li> <li>Format validation</li> <li>Constraint checking</li> </ul>"},{"location":"developers/DatabaseConfig/#_validatequeryoperators","title":"<code>_validateQueryOperators()</code>","text":"<p>Ensures logical operators are a subset of supported operators and raises <code>INVALID_ARGUMENT</code> when alignment fails.</p>"},{"location":"developers/DatabaseConfig/#_validateoperatorarrayconfigkey-operators-rawvalue-wasprovided","title":"<code>_validateOperatorArray(configKey, operators, rawValue, wasProvided)</code>","text":"<p>Validates optional operator arrays against type constraints and preserves the original error context.</p>"},{"location":"developers/DatabaseConfig/#validation-rules","title":"Validation Rules","text":""},{"location":"developers/DatabaseConfig/#property-validation","title":"Property Validation","text":"<p>lockTimeout:</p> <ul> <li>Must be a number of at least 500ms</li> <li>Recommended range: 5000-60000ms</li> <li>Zero is invalid because the minimum is enforced during validation</li> </ul> <p>retryAttempts / retryDelayMs / lockRetryBackoffBase:</p> <ul> <li><code>retryAttempts</code> must be a positive integer</li> <li><code>retryDelayMs</code> must be a non-negative number</li> <li><code>lockRetryBackoffBase</code> must be a positive number</li> </ul> <p>logLevel:</p> <ul> <li>Must be one of the entries in <code>LOG_LEVELS</code> (currently 'DEBUG', 'INFO', 'WARN', 'ERROR')</li> <li>Case-sensitive validation</li> <li>Defaults to <code>DEFAULT_LOG_LEVEL</code> to remain consistent with <code>JDbLogger</code></li> <li>Affects logging verbosity across the system</li> </ul> <p>rootFolderId:</p> <ul> <li>Must be a valid string if provided</li> <li>Auto-detected if not specified</li> <li>Should correspond to accessible Drive folder</li> <li>Default root folder lookups are cached after first access to avoid repeated Drive API calls</li> </ul> <p>Boolean Properties:</p> <ul> <li><code>autoCreateCollections</code>: Must be true or false</li> <li><code>cacheEnabled</code>: Must be true or false</li> <li>Type coercion not performed</li> <li><code>stripDisallowedCollectionNameCharacters</code>: Must be true or false; default <code>false</code> enforces strict rejection of invalid names, while <code>true</code> enables sanitisation.</li> </ul> <p>masterIndexKey:</p> <ul> <li>Must be a non-empty string</li> <li>Used as ScriptProperties key</li> <li>Should be unique per database instance</li> </ul> <p>File retry settings:</p> <ul> <li><code>fileRetryAttempts</code> must be a positive integer</li> <li><code>fileRetryDelayMs</code> must be a non-negative number</li> <li><code>fileRetryBackoffBase</code> must be a positive number</li> </ul> <p>QueryEngine settings:</p> <ul> <li><code>queryEngineMaxNestedDepth</code> must be an integer greater than or equal to zero</li> <li><code>queryEngineSupportedOperators</code> must be a non-empty array of non-empty strings</li> <li><code>queryEngineLogicalOperators</code> must be a non-empty array of non-empty strings, each present in <code>queryEngineSupportedOperators</code></li> </ul>"},{"location":"developers/DatabaseConfig/#error-scenarios","title":"Error Scenarios","text":"<p>Common validation errors and their meanings:</p> Error Message Cause Solution \"Lock timeout must be a number\" Invalid timeout value Use a number of at least 500ms \"Log level must be one of: DEBUG, INFO, WARN, ERROR\" Invalid log level Use exact string match \"Auto create collections must be a boolean\" Non-boolean value Use true or false explicitly \"Failed to get default root folder\" Drive access issue Check permissions and authentication \"Collection sanitisation flag must be a boolean\" Non-boolean value for <code>stripDisallowedCollectionNameCharacters</code> Use true or false explicitly"},{"location":"developers/DatabaseConfig/#usage-examples","title":"Usage Examples","text":""},{"location":"developers/DatabaseConfig/#basic-configuration","title":"Basic Configuration","text":"<pre><code>// Minimal configuration (uses defaults)\nconst config = new DatabaseConfig();\n\n// Custom root folder\nconst config = new DatabaseConfig({\n  rootFolderId: '1ABC123xyz789'\n});\n\n// Production-ready configuration\nconst config = new DatabaseConfig({\n  rootFolderId: 'prod-folder-id',\n  autoCreateCollections: false,\n  lockTimeout: 10000,\n  logLevel: 'WARN',\n  // Avoid Drive file churn on start; backups occur lazily or explicitly\n  backupOnInitialise: false\n});\n</code></pre>"},{"location":"developers/DatabaseConfig/#development-vs-production","title":"Development vs Production","text":"<pre><code>// Development configuration\nconst devConfig = new DatabaseConfig({\n  autoCreateCollections: true,\n  logLevel: 'DEBUG',\n  cacheEnabled: true,\n  // Enable eager backup if you want an index snapshot each initialise\n  backupOnInitialise: true,\n  // Looser query depth for exploratory work\n  queryEngineMaxNestedDepth: 12\n});\n\n// Production configuration\nconst prodConfig = new DatabaseConfig({\n  rootFolderId: 'production-folder-id',\n  autoCreateCollections: false,\n  lockTimeout: 5000,\n  logLevel: 'ERROR',\n  cacheEnabled: true,\n  backupOnInitialise: false\n});\n</code></pre>"},{"location":"developers/DatabaseConfig/#configuration-cloning","title":"Configuration Cloning","text":"<pre><code>const baseConfig = new DatabaseConfig({\n  rootFolderId: 'base-folder',\n  logLevel: 'INFO'\n});\n\n// Create variation for testing\nconst testConfig = baseConfig.clone();\n// Note: Properties are read-only after creation\n// Clone and create new instance for modifications\n\nconst modifiedConfig = new DatabaseConfig({\n  ...baseConfig.toJSON(),\n  logLevel: 'DEBUG'\n});\n</code></pre>"},{"location":"developers/DatabaseConfig/#configuration-serialization","title":"Configuration Serialization","text":"<pre><code>const config = new DatabaseConfig({\n  autoCreateCollections: false,\n  lockTimeout: 15000\n});\n\n// Serialize for storage or logging\nconst configData = config.toJSON();\nconsole.log('Config:', JSON.stringify(configData, null, 2));\n\n// Recreate from serialised data\nconst restoredConfig = DatabaseConfig.fromJSON(configData);\n</code></pre>"},{"location":"developers/DatabaseConfig/#integration-with-database","title":"Integration with Database","text":"<p>The DatabaseConfig class integrates seamlessly with the Database class. For Apps Script consumers, prefer the public API factories:</p> <pre><code>// First-time setup\nconst db1 = JsonDbApp.createAndInitialiseDatabase(\n  new DatabaseConfig({\n    masterIndexKey: 'myMasterIndex'\n  })\n);\n\n// Load existing database\nconst db2 = JsonDbApp.loadDatabase({\n  masterIndexKey: 'myMasterIndex',\n  logLevel: 'DEBUG',\n  // Only back up MasterIndex to Drive during initialise when explicitly enabled\n  backupOnInitialise: false\n});\n\n// Configuration is validated when constructing DatabaseConfig/Database\ntry {\n  JsonDbApp.loadDatabase({ lockTimeout: -1 }); // Will throw\n} catch (error) {\n  console.error('Invalid configuration:', error.message);\n}\n</code></pre>"},{"location":"developers/DatabaseConfig/#component-level-configuration","title":"Component-Level Configuration","text":"<p>While <code>DatabaseConfig</code> handles database-wide settings, individual components may have their own configuration options:</p>"},{"location":"developers/DatabaseConfig/#queryengine-configuration","title":"QueryEngine Configuration","text":"<p>The QueryEngine uses defaults sourced from <code>DatabaseConfig</code> and is instantiated through <code>DocumentOperations</code>. You can still override defaults by passing a custom config directly to <code>QueryEngine</code> when needed.</p> <pre><code>// QueryEngine has its own configuration\nconst queryEngine = new QueryEngine({\n  maxNestedDepth: 15 // Override default of 10\n});\n\n// DatabaseConfig supplies defaults for collections\nconst dbConfig = new DatabaseConfig({\n  logLevel: 'DEBUG',\n  lockTimeout: 20000,\n  queryEngineMaxNestedDepth: 12,\n  queryEngineSupportedOperators: ['$eq', '$gt', '$lt', '$and', '$or']\n});\n\nconst db = new Database(dbConfig);\n// Collections use the QueryEngine internally with DatabaseConfig defaults\n</code></pre> <p>QueryEngine Options:</p> <ul> <li><code>maxNestedDepth</code> (Number, default: 10): Maximum allowed query nesting depth for security</li> <li><code>supportedOperators</code> (String[], default: <code>['$eq', '$gt', '$lt', '$and', '$or']</code>): Operators permitted by the engine</li> <li><code>logicalOperators</code> (String[], default: <code>['$and', '$or']</code>): Logical operators permitted by the engine</li> </ul>"},{"location":"developers/DatabaseConfig/#fileoperations-configuration","title":"FileOperations Configuration","text":"<p>File operations use retry settings from <code>DatabaseConfig</code> when the <code>Database</code> constructs <code>FileOperations</code>:</p> <ul> <li><code>fileRetryAttempts</code>: Number of retry attempts for Drive operations</li> <li><code>fileRetryDelayMs</code>: Delay between retries</li> <li><code>fileRetryBackoffBase</code>: Exponential backoff base for retries</li> </ul> <p>Security Note: QueryEngine always validates all queries for structure and supported operators to prevent malicious queries, regardless of configuration.</p>"},{"location":"developers/DatabaseConfig/#index-backup-strategy","title":"Index Backup Strategy","text":"<p><code>backupOnInitialise</code> controls whether <code>Database.initialise()</code> performs Drive index creation and backup:</p> <ul> <li><code>false</code> (default): Initialise reads from MasterIndex only; no Drive writes are performed. The Drive-based index is created lazily on first write operation (e.g., <code>createCollection</code>, <code>dropCollection</code>) or when calling <code>database.loadIndex()</code>.</li> <li><code>true</code>: Initialise will create/find the index file in Drive and back up the current MasterIndex immediately. This is useful when you want a snapshot on every start at the cost of additional Drive operations.</li> </ul> <p>Independent of this flag, explicit calls to <code>database.backupIndexToDrive()</code> will always perform a backup if an index file exists.</p>"},{"location":"developers/DatabaseConfig/#best-practices","title":"Best Practices","text":"<ol> <li>Validate early: Create DatabaseConfig instances explicitly to catch errors</li> <li>Use appropriate timeouts: Consider script execution limits when setting lockTimeout</li> <li>Environment-specific configs: Create different configurations for dev/test/prod</li> <li>Immutable configurations: Don't modify config properties after creation</li> <li>Proper folder permissions: Ensure root folder is accessible to the script</li> <li>Sensible logging levels: Use DEBUG for development, INFO/WARN for production</li> <li>Document custom settings: Comment why specific values were chosen</li> <li>Test configuration validation: Include config validation in your tests</li> <li>Security-first design: All components prioritise security over optional performance optimisations</li> <li>Component separation: Each component manages its own configuration appropriate to its responsibilities</li> </ol>"},{"location":"developers/Infrastructure_Components/","title":"Infrastructure Components","text":"<p>\\</p>"},{"location":"developers/Infrastructure_Components/#1-gas-db-infrastructure-components","title":"1. GAS DB Infrastructure Components","text":"<ul> <li>1. GAS DB Infrastructure Components</li> <li>1.1. Overview</li> <li>1.2. Logger (JDbLogger)<ul> <li>1.2.0.1. Key Features</li> <li>1.2.0.2. Core Methods</li> <li>1.2.0.3. Usage Examples</li> <li>1.2.0.4. Best Practices</li> <li>1.2.1. ErrorHandler</li> <li>1.2.1.1. Error Type Hierarchy</li> <li>1.2.1.2. Error Management Methods</li> <li>1.2.1.3. Usage Examples</li> <li>1.2.1.4. Best Practices</li> <li>1.2.2. IdGenerator</li> <li>1.2.2.1. ID Generation Strategies</li> <li>1.2.2.2. Validation Methods</li> <li>1.2.2.3. Custom Generator Creation</li> <li>1.2.2.4. Usage Examples</li> <li>1.2.2.5. Best Practices</li> <li>1.2.3. ObjectUtils</li> <li>1.2.3.1. Core Methods</li> <li>1.2.3.2. Deep Cloning</li> <li>1.2.3.3. Date String Conversion</li> <li>1.2.3.4. Usage Examples</li> <li>1.2.3.5. Best Practices</li> <li>1.2.4. Validate</li> <li>1.2.4.1. Core Methods</li> <li>1.2.4.2. Usage Examples</li> <li>1.2.4.3. Best Practices</li> </ul> </li> <li>1.3. Integration Patterns<ul> <li>1.3.1. Component Integration</li> <li>1.3.2. Standardized Error Flow</li> </ul> </li> <li>1.4. Configuration<ul> <li>1.4.1. Logger Configuration</li> <li>1.4.2. Error Handler Configuration</li> <li>1.4.3. ID Generator Configuration</li> <li>1.4.4. ObjectUtils Configuration</li> </ul> </li> <li>1.5. Performance Considerations</li> <li>1.6. Migration and Versioning<ul> <li>1.6.1. Component Dependencies</li> <li>1.6.2. Extension Points</li> </ul> </li> </ul>"},{"location":"developers/Infrastructure_Components/#11-overview","title":"1.1. Overview","text":"<p>The JsonDbApp infrastructure provides essential utilities for logging, error management, ID generation, and object manipulation. These components are designed specifically for Google Apps Script environments and support the core database functionality.</p>"},{"location":"developers/Infrastructure_Components/#12-logger-jdblogger","title":"1.2. Logger (JDbLogger)","text":"<p>The <code>JDbLogger</code> provides sophisticated logging capabilities with multiple levels, component-specific loggers, and performance tracking.</p> <p>A comprehensive logging utility providing structured logging with multiple levels and context support for Google Apps Script environments.</p>"},{"location":"developers/Infrastructure_Components/#1201-key-features","title":"1.2.0.1. Key Features","text":"<ul> <li>Four Log Levels: ERROR (0), WARN (1), INFO (2), DEBUG (3)</li> <li>Context Support: Rich logging with JSON serializable context objects</li> <li>Component Loggers: Create specialized loggers for different components</li> <li>Operation Timing: Built-in performance monitoring capabilities</li> <li>GAS Compatibility: Works with console.log, console.warn, console.error</li> </ul>"},{"location":"developers/Infrastructure_Components/#1202-core-methods","title":"1.2.0.2. Core Methods","text":"Method Description <code>setLevel(level)</code> Set log level by number (0-3) <code>setLevelByName(name)</code> Set log level by name (ERROR/WARN/INFO/DEBUG) <code>error(message, context)</code> Log error message with optional context <code>warn(message, context)</code> Log warning message with optional context <code>info(message, context)</code> Log info message with optional context <code>debug(message, context)</code> Log debug message with optional context <code>createComponentLogger(component)</code> Create component-specific logger <code>timeOperation(name, fn, context)</code> Time and log operation execution"},{"location":"developers/Infrastructure_Components/#1203-usage-examples","title":"1.2.0.3. Usage Examples","text":"<pre><code>// Basic logging\nJDbLogger.info('Database initialised successfully');\nJDbLogger.error('Failed to read file', { fileId: 'abc123', error: 'Permission denied' });\n\n// Set log level\nJDbLogger.setLevelByName('DEBUG'); // Show all messages\nJDbLogger.setLevelByName('ERROR'); // Show only errors\n\n// Component-specific logging\nconst dbLogger = JDbLogger.createComponentLogger('Database');\ndbLogger.info('Collection created', { name: 'users' });\n\n// Operation timing\nconst result = JDbLogger.timeOperation(\n  'loadCollection',\n  () =&gt; {\n    return loadCollectionFromDrive(collectionId);\n  },\n  { collectionId }\n);\n</code></pre>"},{"location":"developers/Infrastructure_Components/#1204-best-practices","title":"1.2.0.4. Best Practices","text":"<ol> <li>Use appropriate log levels:</li> <li>ERROR: System failures, exceptions</li> <li>WARN: Recoverable issues, deprecated usage</li> <li>INFO: Important state changes, operation completion</li> <li> <p>DEBUG: Detailed execution flow, variable values</p> </li> <li> <p>Include context objects:</p> </li> </ol> <pre><code>this.logger.info('Collection created', {\n  collectionName: name,\n  fileId: fileId,\n  documentCount: 0,\n  timestamp: new Date()\n});\n</code></pre> <ol> <li>Use component loggers:</li> </ol> <pre><code>const logger = JDbLogger.createComponentLogger('Collection');\n</code></pre>"},{"location":"developers/Infrastructure_Components/#121-errorhandler","title":"1.2.1. ErrorHandler","text":"<p>Location: <code>src/01_utils/ErrorHandler.js</code></p> <p>Provides standardized error handling with custom error types and error context management. For input validation, refer to the Validate utility.</p>"},{"location":"developers/Infrastructure_Components/#1211-error-type-hierarchy","title":"1.2.1.1. Error Type Hierarchy","text":"<p>All errors extend the base <code>GASDBError</code> class and include:</p> <ul> <li>Error code for programmatic handling</li> <li>Context object for debugging information</li> <li>Timestamp for error tracking</li> </ul> <p>The shared <code>ERROR_CODES</code> catalogue mirrors the registered error types so consumers who prefer constants over string literals can import and compare against those values without relying on free-form strings.</p> Error Class Code Usage <code>DocumentNotFoundError</code> <code>DOCUMENT_NOT_FOUND</code> Document queries that return no results <code>DuplicateKeyError</code> <code>DUPLICATE_KEY</code> Unique constraint violations <code>InvalidQueryError</code> <code>INVALID_QUERY</code> Malformed query syntax <code>LockTimeoutError</code> <code>LOCK_TIMEOUT</code> Lock acquisition failures <code>FileIOError</code> <code>FILE_IO_ERROR</code> Drive API operation failures <code>ConflictError</code> <code>CONFLICT_ERROR</code> Modification token mismatches <code>MasterIndexError</code> <code>MASTER_INDEX_ERROR</code> ScriptProperties access failures <code>CollectionNotFoundError</code> <code>COLLECTION_NOT_FOUND</code> Missing collection references <code>ConfigurationError</code> <code>CONFIGURATION_ERROR</code> Invalid configuration values <code>FileNotFoundError</code> <code>FILE_NOT_FOUND</code> Specific file not found on Drive <code>PermissionDeniedError</code> <code>PERMISSION_DENIED</code> Lack of permission for a file operation <code>QuotaExceededError</code> <code>QUOTA_EXCEEDED</code> Google Drive API quota limits reached <code>InvalidFileFormatError</code> <code>INVALID_FILE_FORMAT</code> File content does not match expected format (e.g., not valid JSON) <code>InvalidArgumentError</code> <code>INVALID_ARGUMENT</code> Incorrect or missing function arguments (also used by Validate class) <code>OperationError</code> <code>OPERATION_ERROR</code> General failure during an operation not covered by other error types <code>LockAcquisitionFailureError</code> <code>LOCK_ACQUISITION_FAILURE</code> Lock attempts that fail immediately without waiting (e.g., contention without timeout) <code>ModificationConflictError</code> <code>MODIFICATION_CONFLICT</code> Fine-grained token mismatches where a more specific conflict signal is required <code>CoordinationTimeoutError</code> <code>COORDINATION_TIMEOUT</code> Cross-component orchestration exceeded the allotted coordination window <p>When creating new subclasses, use the <code>createErrorConstructorArgs</code> helper to assemble the standard <code>(message, code, context)</code> tuple. This keeps constructors minimal and ensures new errors align with the catalogued codes and logging expectations.</p>"},{"location":"developers/Infrastructure_Components/#1212-error-management-methods","title":"1.2.1.2. Error Management Methods","text":"Method Description <code>createError(errorType, ...args)</code> Create new error of specified type <code>handleError(error, context, rethrow)</code> Handle error with logging and optional re-throw <code>wrapFunction(fn, context)</code> Wrap function with error handling <code>isErrorType(error, errorType)</code> Check if error is of specific type <code>extractErrorInfo(error)</code> Extract error information for logging <code>detectDoubleParsing(data, parseError, context)</code> Detects and throws a specific error if data is already a parsed object."},{"location":"developers/Infrastructure_Components/#1213-usage-examples","title":"1.2.1.3. Usage Examples","text":"<pre><code>// Create and throw specific errors\nthrow ErrorHandler.createError('DOCUMENT_NOT_FOUND', { _id: 'doc123' }, 'users');\n\n// Handle errors with logging\ntry {\n  performDatabaseOperation();\n} catch (error) {\n  ErrorHandler.handleError(error, 'Database.performOperation', true);\n}\n\n// Wrap functions with error handling\nconst safeFunction = ErrorHandler.wrapFunction(riskyOperation, 'RiskyOperation');\n</code></pre>"},{"location":"developers/Infrastructure_Components/#1214-best-practices","title":"1.2.1.4. Best Practices","text":"<ol> <li>Use specific error types:</li> </ol> <pre><code>throw new DocumentNotFoundError(query, collectionName);\n</code></pre> <ol> <li>Preserve error context:</li> </ol> <pre><code>ErrorHandler.handleError(error, 'Collection.findOne', true);\n</code></pre>"},{"location":"developers/Infrastructure_Components/#122-idgenerator","title":"1.2.2. IdGenerator","text":"<p>Location: <code>src/utils/IdGenerator.js</code></p> <p>Provides multiple strategies for generating unique identifiers suitable for different use cases in the database system.</p>"},{"location":"developers/Infrastructure_Components/#1221-id-generation-strategies","title":"1.2.2.1. ID Generation Strategies","text":"Method Output Example Use Case <code>generateUUID()</code> <code>f47ac10b-58cc-4372-a567-0e02b2c3d479</code> Default document IDs <code>generateTimestampId(prefix)</code> <code>token_1640995200000_123</code> Time-ordered IDs, modification tokens <code>generateShortId(length)</code> <code>a1b2c3d4</code> Compact identifiers <code>generateAlphanumericId(length)</code> <code>A1b2C3d4E5f6</code> General purpose IDs <code>generateNumericId(length)</code> <code>1234567890</code> Numeric-only IDs <code>generateObjectId()</code> <code>507f1f77bcf86cd799439011</code> MongoDB compatibility <code>generateSequentialId(prefix)</code> <code>seq_1640995200000_000001</code> Ordered sequences <code>generateReadableId()</code> <code>quick-cat-123</code> Human-friendly IDs"},{"location":"developers/Infrastructure_Components/#1222-validation-methods","title":"1.2.2.2. Validation Methods","text":"Method Description <code>isValidUUID(id)</code> Check if string is valid UUID format <code>isValidObjectId(id)</code> Check if string is valid ObjectId format"},{"location":"developers/Infrastructure_Components/#1223-custom-generator-creation","title":"1.2.2.3. Custom Generator Creation","text":"<pre><code>// Create custom generators for specific needs\nconst tokenGenerator = IdGenerator.createCustomGenerator({\n  type: 'timestamp',\n  prefix: 'token'\n});\n\nconst shortCodeGenerator = IdGenerator.createCustomGenerator({\n  type: 'alphanumeric',\n  length: 8\n});\n\nconst readableGenerator = IdGenerator.createCustomGenerator({\n  type: 'readable'\n});\n</code></pre>"},{"location":"developers/Infrastructure_Components/#1224-usage-examples","title":"1.2.2.4. Usage Examples","text":"<pre><code>// Generate document IDs\nconst documentId = IdGenerator.generateUUID();\n\n// Generate modification tokens\nconst token = IdGenerator.generateTimestampId('token');\n\n// Create custom generators\nconst customGenerator = IdGenerator.createCustomGenerator({\n  type: 'alphanumeric',\n  length: 16\n});\nconst customId = customGenerator();\n\n// Validate ID formats\nif (IdGenerator.isValidUUID(documentId)) {\n  processDocument(documentId);\n}\n</code></pre>"},{"location":"developers/Infrastructure_Components/#1225-best-practices","title":"1.2.2.5. Best Practices","text":"<ol> <li>Use appropriate ID types:</li> <li>UUIDs for document IDs (default)</li> <li>Timestamp IDs for modification tokens</li> <li>ObjectIDs for MongoDB compatibility</li> <li> <p>Readable IDs for debugging and testing</p> </li> <li> <p>Validate ID formats:</p> </li> </ol> <pre><code>if (!IdGenerator.isValidUUID(documentId)) {\n  throw new InvalidArgumentError('Invalid document ID format');\n}\n</code></pre>"},{"location":"developers/Infrastructure_Components/#123-objectutils","title":"1.2.3. ObjectUtils","text":"<p>Location: <code>src/utils/ObjectUtils.js</code></p> <p>Provides utilities for object manipulation with Date preservation, essential for handling complex data structures and maintaining Date object integrity during JSON serialisation operations.</p>"},{"location":"developers/Infrastructure_Components/#1231-core-methods","title":"1.2.3.1. Core Methods","text":"Method Description <code>deepClone(obj)</code> Create deep copy preserving Date instances and object structure <code>convertDateStringsToObjects(obj)</code> Convert ISO date strings to Date objects recursively"},{"location":"developers/Infrastructure_Components/#1232-deep-cloning","title":"1.2.3.2. Deep Cloning","text":"<p>The <code>deepClone</code> method creates independent copies of complex objects while preserving:</p> <ul> <li>Date Objects: Maintains Date instances with accurate time values</li> <li>Nested Structures: Handles deeply nested objects and arrays</li> <li>Independence: Ensures modifications to cloned objects don't affect originals</li> <li>Type Preservation: Maintains primitive types and object references</li> </ul> <p>Supported Data Types:</p> <ul> <li>Primitives: <code>null</code>, <code>undefined</code>, <code>string</code>, <code>number</code>, <code>boolean</code></li> <li>Complex Types: <code>Date</code>, <code>Array</code>, <code>Object</code></li> <li>Nested Structures: Unlimited depth for objects and arrays</li> </ul>"},{"location":"developers/Infrastructure_Components/#1233-date-string-conversion","title":"1.2.3.3. Date String Conversion","text":"<p>The <code>convertDateStringsToObjects</code> method provides intelligent conversion of ISO date strings:</p> <ul> <li>ISO Detection: Identifies valid ISO 8601 format strings (<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>)</li> <li>Selective Conversion: Only converts valid ISO strings, leaves others unchanged</li> <li>In-Place Modification: Modifies original object structure</li> <li>Recursive Processing: Handles nested objects and arrays</li> </ul> <p>ISO Date Format Requirements:</p> <ul> <li>Complete date-time format: <code>2023-06-15T10:30:00.000Z</code></li> <li>Timezone indicator: Must end with <code>Z</code></li> <li>Optional milliseconds: Supports both <code>.sssZ</code> and <code>Z</code> endings</li> <li>Valid date values: Validates month, day, hour, minute, second ranges</li> </ul>"},{"location":"developers/Infrastructure_Components/#1234-usage-examples","title":"1.2.3.4. Usage Examples","text":"<pre><code>// Deep cloning with Date preservation\nconst originalDoc = {\n  _id: 'doc123',\n  created: new Date('2023-06-15T10:30:00.000Z'),\n  user: {\n    name: 'John Doe',\n    profile: {\n      lastLogin: new Date('2024-06-11T10:00:00.000Z'),\n      preferences: ['theme-dark', 'lang-en']\n    }\n  },\n  tags: ['important', 'archived']\n};\n\nconst clonedDoc = ObjectUtils.deepClone(originalDoc);\n// clonedDoc is completely independent with Date objects preserved\n\n// Converting date strings from JSON parsing\nconst jsonData = {\n  event: {\n    startTime: '2023-06-15T10:30:00.000Z', // Will be converted to Date\n    endTime: '2023-06-15 12:30:00', // Will remain string (invalid ISO)\n    participants: [\n      {\n        joined: '2023-06-15T10:35:00.000Z', // Will be converted to Date\n        name: 'Alice' // Will remain string\n      }\n    ]\n  }\n};\n\nObjectUtils.convertDateStringsToObjects(jsonData);\n// jsonData.event.startTime is now a Date object\n// jsonData.event.participants[0].joined is now a Date object\n\n// Working with FileOperations integration\nconst documentData = {\n  metadata: { created: new Date(), version: 1 },\n  content: { title: 'Document', lastModified: new Date() }\n};\n\n// Before saving to Drive (preserves Dates through JSON)\nfileOps.writeFile(fileId, documentData);\n\n// After reading from Drive (converts ISO strings back to Dates)\nconst loadedData = fileOps.readFile(fileId);\n// loadedData now has proper Date objects restored\n</code></pre>"},{"location":"developers/Infrastructure_Components/#1235-best-practices","title":"1.2.3.5. Best Practices","text":"<ol> <li>Use deepClone for object independence:</li> </ol> <pre><code>// Create independent copy before modifications\nconst workingCopy = ObjectUtils.deepClone(originalDocument);\nworkingCopy.user.name = 'Updated Name'; // Original remains unchanged\n</code></pre> <ol> <li>Apply date conversion after JSON operations:</li> </ol> <pre><code>// After parsing JSON or reading from Drive\nconst parsedData = JSON.parse(jsonString);\nObjectUtils.convertDateStringsToObjects(parsedData);\n</code></pre> <ol> <li>Handle FileOperations integration:</li> </ol> <pre><code>// Reading data with automatic date conversion\nconst rawData = fileOps.readFile(fileId);\n// Date strings automatically converted by FileOperations using ObjectUtils\n</code></pre> <ol> <li>Validate data integrity:</li> </ol> <pre><code>// Verify Date objects after conversion\nif (document.created instanceof Date) {\n  // Safe to use Date methods\n  const age = Date.now() - document.created.getTime();\n}\n</code></pre> <ol> <li>Performance considerations:</li> </ol> <pre><code>// Clone only when necessary for independence\nconst backup = ObjectUtils.deepClone(criticalData);\n\n// Use direct references for read-only operations\nconst readOnlyView = criticalData; // No cloning needed\n</code></pre>"},{"location":"developers/Infrastructure_Components/#124-validate","title":"1.2.4. Validate","text":"<p>Location: <code>src/01_utils/Validation.js</code></p> <p>Provides a collection of static methods for common data validation tasks, ensuring consistency and reducing boilerplate code. All validation methods throw <code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code> upon failure, providing the parameter name and a descriptive reason.</p>"},{"location":"developers/Infrastructure_Components/#1241-core-methods","title":"1.2.4.1. Core Methods","text":"Method Description <code>required(value, paramName)</code> Ensures <code>value</code> is not <code>null</code> or <code>undefined</code>. <code>type(value, expectedType, paramName)</code> Validates that <code>value</code> is of the <code>expectedType</code> (e.g., 'string', 'number', 'object'). <code>nonEmptyString(value, paramName)</code> Checks if <code>value</code> is a string and is not empty or composed only of whitespace. <code>string(value, paramName)</code> Checks if <code>value</code> is a string. Allows empty strings. <code>object(value, paramName, allowEmpty = true)</code> Validates if <code>value</code> is an object (and not an array or <code>null</code>). If <code>allowEmpty</code> is <code>false</code>, an empty object will also fail validation. <code>boolean(value, paramName)</code> Ensures <code>value</code> is a boolean (<code>true</code> or <code>false</code>). <code>array(value, paramName)</code> Validates if <code>value</code> is an array. <code>nonEmptyArray(value, paramName)</code> Ensures <code>value</code> is an array containing at least one element. <code>number(value, paramName)</code> Checks if <code>value</code> is a number (and not <code>NaN</code>). <code>integer(value, paramName)</code> Validates if <code>value</code> is an integer. <code>positiveNumber(value, paramName)</code> Ensures <code>value</code> is a number strictly greater than zero. <code>nonNegativeNumber(value, paramName)</code> Ensures <code>value</code> is a number greater than or equal to zero. <code>range(value, min, max, paramName)</code> Checks if a numeric <code>value</code> falls within the inclusive range defined by <code>min</code> and <code>max</code>. <code>func(value, paramName)</code> Validates if <code>value</code> is a function. <code>enum(value, allowedValues, paramName)</code> Ensures <code>value</code> is present in the <code>allowedValues</code> array. <code>objectProperties(obj, requiredProps, paramName)</code> Checks if the object <code>obj</code> possesses all property names listed in the <code>requiredProps</code> array. <code>pattern(value, pattern, paramName, description)</code> Validates if a string <code>value</code> matches the provided <code>RegExp</code> <code>pattern</code>. The <code>description</code> is used in the error message. <code>optional(value, validationFn, paramName)</code> If <code>value</code> is not <code>null</code> or <code>undefined</code>, applies the <code>validationFn</code> to it. Otherwise, passes. <code>all(validators, value, paramName)</code> Ensures <code>value</code> successfully passes all validation functions provided in the <code>validators</code> array. Each function in <code>validators</code> should accept <code>(value, paramName)</code>. <code>any(validators, value, paramName)</code> Ensures <code>value</code> successfully passes at least one validation function from the <code>validators</code> array. Each function in <code>validators</code> should accept <code>(value, paramName)</code>. <code>validateObject(value, paramName)</code> Validates if <code>value</code> is a \"plain\" object (i.e., created by <code>{}</code> or <code>new Object()</code>, not an array, <code>null</code>, or an instance of <code>Date</code>). <code>isPlainObject(value)</code> A helper method that returns <code>true</code> if <code>value</code> is a plain object, <code>false</code> otherwise. Not typically used for direct validation throwing errors but can be used for conditional logic. <code>validateUpdateObject(update, paramName, options = {})</code> Validates the structure of a MongoDB-style update object. <code>options</code> can include: <code>allowMixed</code> (boolean, default <code>false</code>), <code>requireOperators</code> (boolean, default <code>false</code>), <code>forbidOperators</code> (boolean, default <code>false</code>)."},{"location":"developers/Infrastructure_Components/#1242-usage-examples","title":"1.2.4.2. Usage Examples","text":"<pre><code>// Ensuring a parameter is provided\nValidate.required(userId, 'userId');\n\n// Type checking\nValidate.type(config, 'object', 'config');\nValidate.nonEmptyString(collectionName, 'collectionName');\nValidate.number(count, 'count');\n\n// Number constraints\nValidate.positiveNumber(limit, 'limit');\nValidate.range(age, 0, 120, 'age');\n\n// Object and array validation\nValidate.object(settings, 'settings');\nValidate.nonEmptyArray(tags, 'tags');\nValidate.objectProperties(userProfile, ['username', 'email'], 'userProfile');\n\n// Enum validation\nValidate.enum(status, ['active', 'inactive', 'pending'], 'status');\n\n// Pattern matching for a string\nValidate.pattern(email, /\\\\S+@\\\\S+\\\\.\\\\S+/, 'email', 'a valid email address format');\n\n// Optional field validation\n// 'description' can be null/undefined, but if it exists, it must be a string.\nValidate.optional(description, Validate.string, 'description');\n\n// Combining multiple validations for a single field\nValidate.all(\n  [\n    (val, name) =&gt; Validate.string(val, name), // Must be a string\n    (val, name) =&gt; Validate.nonEmptyString(val, name), // Must not be empty\n    (val, name) =&gt;\n      Validate.pattern(\n        val,\n        /^[a-zA-Z0-9_]{3,16}$/,\n        name,\n        '3-16 alphanumeric characters or underscores'\n      ) // Must match pattern\n  ],\n  username,\n  'username'\n);\n\n// Validating update objects (e.g., for database operations)\ntry {\n  Validate.validateUpdateObject({ $set: { name: 'New Name' }, status: 'active' }, 'updatePayload'); // Fails by default (mixed)\n} catch (e) {\n  // console.error(e.message); // \"updatePayload cannot mix update operators with document fields\"\n}\nValidate.validateUpdateObject({ $set: { name: 'New Name' }, status: 'active' }, 'updatePayload', {\n  allowMixed: true\n}); // Passes\nValidate.validateUpdateObject({ name: 'New Name' }, 'updatePayload', { forbidOperators: true }); // Passes\nValidate.validateUpdateObject({ $inc: { score: 1 } }, 'updatePayload', { requireOperators: true }); // Passes\n</code></pre>"},{"location":"developers/Infrastructure_Components/#1243-best-practices","title":"1.2.4.3. Best Practices","text":"<ol> <li>Early and Often: Apply validation at the entry points of your functions and methods to catch errors early and prevent invalid data from propagating.</li> <li>Clear Parameter Names: Use descriptive <code>paramName</code> arguments, as they are included in error messages, aiding debugging.</li> <li>Leverage <code>Validate.optional</code>: For fields that are not mandatory but must conform to a type or rule if present.</li> <li>Compose with <code>Validate.all</code> and <code>Validate.any</code>: For complex validation scenarios involving multiple conditions on a single piece of data.</li> <li>Specific Over Generic: Prefer specific validators like <code>nonEmptyString</code> or <code>positiveNumber</code> over more generic ones like <code>string</code> or <code>number</code> when applicable, to provide more precise validation.</li> <li>Understand Plain Objects: When using <code>validateObject</code> or <code>isPlainObject</code>, be aware that it specifically checks for objects that are not arrays or instances of other complex types like <code>Date</code>.</li> <li>Update Object Validation: Use <code>validateUpdateObject</code> when dealing with MongoDB-style update operations to ensure structural correctness.</li> </ol>"},{"location":"developers/Infrastructure_Components/#13-integration-patterns","title":"1.3. Integration Patterns","text":""},{"location":"developers/Infrastructure_Components/#131-component-integration","title":"1.3.1. Component Integration","text":"<p>All infrastructure components are designed to work together seamlessly:</p> <pre><code>// Example: Database component using all utilities\nclass Database {\n  constructor(config) {\n    // Validate configuration\n    ValidationUtils.validateRequired(config, 'config');\n    ValidationUtils.validateType(config.rootFolderId, 'string', 'rootFolderId');\n\n    // Set up logging\n    this.logger = JDbLogger.createComponentLogger('Database');\n    this.logger.info('Initializing database', { config });\n\n    // Generate instance ID\n    this.instanceId = IdGenerator.generateUUID();\n  }\n\n  performOperation(operationName, operationFn) {\n    return JDbLogger.timeOperation(\n      operationName,\n      () =&gt; {\n        try {\n          return operationFn();\n        } catch (error) {\n          ErrorHandler.handleError(error, `Database.${operationName}`, true);\n        }\n      },\n      { instanceId: this.instanceId }\n    );\n  }\n\n  cloneDocumentSafely(document) {\n    // Use ObjectUtils for safe document cloning with Date preservation\n    return ObjectUtils.deepClone(document);\n  }\n\n  processFileData(fileData) {\n    // Convert ISO date strings from JSON to Date objects\n    ObjectUtils.convertDateStringsToObjects(fileData);\n    return fileData;\n  }\n}\n</code></pre>"},{"location":"developers/Infrastructure_Components/#132-standardized-error-flow","title":"1.3.2. Standardized Error Flow","text":"<pre><code>// Standard error handling pattern across all components\nclass Collection {\n  findOne(query) {\n    try {\n      ValidationUtils.validateRequired(query, 'query');\n      ValidationUtils.validateType(query, 'object', 'query');\n\n      const result = this._performFind(query);\n\n      if (!result) {\n        throw new DocumentNotFoundError(query, this.name);\n      }\n\n      return result;\n    } catch (error) {\n      ErrorHandler.handleError(error, 'Collection.findOne', true);\n    }\n  }\n}\n</code></pre>"},{"location":"developers/Infrastructure_Components/#14-configuration","title":"1.4. Configuration","text":""},{"location":"developers/Infrastructure_Components/#141-logger-configuration","title":"1.4.1. Logger Configuration","text":"<pre><code>// Set global log level\nJDbLogger.setLevelByName('DEBUG'); // Development\nJDbLogger.setLevelByName('INFO'); // Production\n\n// Component-specific configuration\nconst dbLogger = JDbLogger.createComponentLogger('Database');\nconst collectionLogger = JDbLogger.createComponentLogger('Collection');\n</code></pre> <p><code>DatabaseConfig</code> enforces these names via its <code>LOG_LEVELS</code> constant and defaults to <code>DEFAULT_LOG_LEVEL</code> (<code>'INFO'</code>), ensuring runtime configuration always maps cleanly onto <code>JDbLogger</code> expectations.</p>"},{"location":"developers/Infrastructure_Components/#142-error-handler-configuration","title":"1.4.2. Error Handler Configuration","text":"<pre><code>// Error types are pre-configured in ErrorHandler.ErrorTypes\nconst errorType = ErrorHandler.ErrorTypes.DOCUMENT_NOT_FOUND;\n\n// Custom error handling\nconst customErrorHandler = (error, context) =&gt; {\n  ErrorHandler.handleError(error, context, false); // Don't re-throw\n  // Custom recovery logic here\n};\n</code></pre>"},{"location":"developers/Infrastructure_Components/#143-id-generator-configuration","title":"1.4.3. ID Generator Configuration","text":"<pre><code>// Set up generators for different use cases\nconst documentIdGenerator = IdGenerator.getDefaultGenerator(); // UUID\nconst tokenGenerator = IdGenerator.createCustomGenerator({\n  type: 'timestamp',\n  prefix: 'token'\n});\nconst debugIdGenerator = IdGenerator.createCustomGenerator({\n  type: 'readable'\n});\n</code></pre>"},{"location":"developers/Infrastructure_Components/#144-objectutils-configuration","title":"1.4.4. ObjectUtils Configuration","text":"<pre><code>// ObjectUtils is stateless and requires no configuration\n// Methods are called directly on the class\n\n// Example integration with FileOperations\nclass FileOperations {\n  readFile(fileId) {\n    const rawData = this._readFromDrive(fileId);\n    const parsedData = JSON.parse(rawData);\n\n    // Automatically convert ISO date strings to Date objects\n    ObjectUtils.convertDateStringsToObjects(parsedData);\n    return parsedData;\n  }\n\n  writeFile(fileId, data) {\n    // Create independent copy to avoid modifying original\n    const dataToWrite = ObjectUtils.deepClone(data);\n    const jsonString = JSON.stringify(dataToWrite);\n    return this._writeToDrive(fileId, jsonString);\n  }\n}\n</code></pre>"},{"location":"developers/Infrastructure_Components/#15-performance-considerations","title":"1.5. Performance Considerations","text":"<ol> <li>Logging: Use appropriate log levels to avoid performance impact in production</li> <li>Error Handling: Error context objects are JSON serialised, avoid large objects</li> <li>ID Generation: UUID generation uses Google Apps Script utilities for optimal performance</li> <li>Validation: Input validation is performed early to fail fast</li> <li>ObjectUtils: Deep cloning and date conversion have performance implications for large objects</li> <li>Use <code>deepClone</code> judiciously for large nested structures</li> <li><code>convertDateStringsToObjects</code> modifies objects in-place for efficiency</li> <li>Consider object size and nesting depth when using these utilities</li> </ol>"},{"location":"developers/Infrastructure_Components/#16-migration-and-versioning","title":"1.6. Migration and Versioning","text":"<p>All infrastructure components are designed to be stable and backwards compatible. Future versions will maintain API compatibility while potentially adding new features.</p>"},{"location":"developers/Infrastructure_Components/#161-component-dependencies","title":"1.6.1. Component Dependencies","text":"<ul> <li>JDbLogger: Self-contained, no dependencies</li> <li>ErrorHandler: Uses JDbLogger for error logging</li> <li>IdGenerator: Self-contained, uses Google Apps Script Utilities when available</li> <li>ObjectUtils: Self-contained, no dependencies</li> </ul>"},{"location":"developers/Infrastructure_Components/#162-extension-points","title":"1.6.2. Extension Points","text":"<p>These components can be extended for future functionality:</p> <ol> <li>Custom Log Destinations: Extend JDbLogger to support additional output targets</li> <li>Additional Error Types: Add new error classes that extend GASDBError</li> <li>New ID Strategies: Add additional generation methods to IdGenerator</li> <li>Object Manipulation: Add additional utility methods to ObjectUtils for specialized data handling</li> </ol> <p>This infrastructure forms the foundation for all other GAS DB components and follows established patterns for reliability, maintainability, and performance in Google Apps Script environments. The combination of logging (JDbLogger), error management (ErrorHandler), ID generation (IdGenerator), and object manipulation (ObjectUtils) provides a comprehensive utility layer that supports sophisticated database operations while maintaining data integrity and system stability.</p>"},{"location":"developers/MasterIndex/","title":"MasterIndex Developer Documentation","text":"<ul> <li>MasterIndex Developer Documentation</li> <li>Overview</li> <li>Internal Helper Components<ul> <li>MasterIndexMetadataNormaliser</li> <li>MasterIndexLockManager Helper Methods \u2b50 NEW in v0.0.5</li> <li><code>_setAndPersistLockStatus(collectionName, collection, lockStatus)</code></li> <li>MasterIndexConflictResolver Helper Methods \u2b50 NEW in v0.0.5</li> <li><code>_applyMetadataUpdates(collectionMetadata, updates)</code></li> </ul> </li> <li>Core Workflow<ul> <li>Collection Access Protocol</li> <li>Virtual Locking</li> <li>Data Structure</li> </ul> </li> <li>Constructor</li> <li>API Reference<ul> <li>Core Methods</li> <li><code>addCollection(name, metadata)</code></li> <li><code>getCollection(name)</code> / <code>getCollections()</code></li> <li><code>updateCollectionMetadata(name, updates)</code></li> <li><code>removeCollection(name)</code></li> <li><code>getCollections()</code></li> <li>Locking Methods</li> <li><code>acquireLock(collectionName, operationId)</code></li> <li><code>releaseLock(collectionName, operationId)</code></li> <li><code>isLocked(collectionName)</code></li> <li><code>cleanupExpiredLocks()</code></li> <li>Conflict Management</li> <li><code>hasConflict(collectionName, expectedToken)</code></li> <li><code>resolveConflict(collectionName, newData, strategy)</code></li> <li><code>generateModificationToken()</code></li> <li><code>validateModificationToken(token)</code></li> </ul> </li> <li>Usage Examples<ul> <li>Basic Operations</li> <li>Locking Pattern</li> <li>Conflict Resolution</li> </ul> </li> <li>Integration with Database Class<ul> <li>Collection Lifecycle Integration</li> <li>Data Synchronisation</li> <li>Locking Coordination</li> </ul> </li> <li>Error Types</li> <li>Best Practices</li> </ul>"},{"location":"developers/MasterIndex/#overview","title":"Overview","text":"<p>The <code>MasterIndex</code> class manages cross-instance coordination for GAS DB using ScriptProperties. It provides virtual locking, conflict detection, and collection metadata management. Following the Section 4 refactoring, <code>MasterIndex</code> serves as the primary source of truth for collection metadata, with the <code>Database</code> class delegating all collection management operations to it.</p> <p>Key Responsibilities:</p> <ul> <li>Cross-instance coordination via ScriptProperties</li> <li>Virtual locking for collection access</li> <li>Conflict detection using modification tokens</li> <li>Collection metadata management (primary source of truth)</li> <li>Integration with Database class for collection lifecycle management</li> </ul> <p>Storage: ScriptProperties with key <code>GASDB_MASTER_INDEX</code></p> <p>Integration with Database Class: The <code>Database</code> class delegates collection operations to <code>MasterIndex</code>:</p> <ul> <li>Collection creation, access, and deletion</li> <li>Collection listing and metadata retrieval</li> <li>Backup synchronisation to Drive-based index files</li> </ul>"},{"location":"developers/MasterIndex/#internal-helper-components","title":"Internal Helper Components","text":""},{"location":"developers/MasterIndex/#masterindexmetadatanormaliser","title":"MasterIndexMetadataNormaliser","text":"<p>Location: src/04_core/MasterIndex/01_MasterIndexMetadataNormaliser.js</p> <p>Encapsulates the transformation of incoming metadata into <code>CollectionMetadata</code> instances. The normaliser clamps timestamps, clones lock status payloads, and ensures modification tokens are generated when missing. This keeps <code>_addCollectionInternal</code> and bulk operations lean while guaranteeing consistent metadata regardless of input type (plain object or existing <code>CollectionMetadata</code>).</p>"},{"location":"developers/MasterIndex/#masterindexlockmanager-helper-methods-new-in-v005","title":"MasterIndexLockManager Helper Methods \u2b50 NEW in v0.0.5","text":"<p>Location: src/04_core/MasterIndex/02_MasterIndexLockManager.js</p> <p>Added in: MI2 refactoring</p>"},{"location":"developers/MasterIndex/#_setandpersistlockstatuscollectionname-collection-lockstatus","title":"<code>_setAndPersistLockStatus(collectionName, collection, lockStatus)</code>","text":"<p>Centralized helper for setting and persisting lock status with guaranteed ordering.</p> <ul> <li>Parameters:</li> <li><code>collectionName</code> (String): Name of collection to update</li> <li><code>collection</code> (CollectionMetadata): Collection metadata object</li> <li><code>lockStatus</code> (Object|null): Lock status to apply</li> <li>Behaviour:</li> <li>Sets lock status on collection metadata</li> <li>Persists to MasterIndex via <code>_updateCollectionMetadataInternal()</code></li> <li>Usage: Used by <code>acquireCollectionLock()</code>, <code>releaseCollectionLock()</code>, <code>cleanupExpiredLocks()</code></li> <li>Benefits: Single source of truth for lock persistence, guaranteed update ordering</li> </ul>"},{"location":"developers/MasterIndex/#masterindexconflictresolver-helper-methods-new-in-v005","title":"MasterIndexConflictResolver Helper Methods \u2b50 NEW in v0.0.5","text":"<p>Location: src/04_core/MasterIndex/04_MasterIndexConflictResolver.js</p> <p>Added in: MI1 refactoring</p>"},{"location":"developers/MasterIndex/#_applymetadataupdatescollectionmetadata-updates","title":"<code>_applyMetadataUpdates(collectionMetadata, updates)</code>","text":"<p>Centralized helper for applying metadata field updates during conflict resolution.</p> <ul> <li>Parameters:</li> <li><code>collectionMetadata</code> (CollectionMetadata): Metadata object to update</li> <li><code>updates</code> (Object): Map of field names to values</li> <li>Behaviour:</li> <li>Iterates through update keys</li> <li>Applies known fields (<code>documentCount</code>, <code>lockStatus</code>) via setter methods</li> <li>Ignores unknown fields</li> <li>Usage: Used by <code>_applyLastWriteWins()</code> for conflict resolution</li> <li>Benefits: Single source of truth for metadata updates, consistent update semantics, easier to extend</li> </ul>"},{"location":"developers/MasterIndex/#core-workflow","title":"Core Workflow","text":""},{"location":"developers/MasterIndex/#collection-access-protocol","title":"Collection Access Protocol","text":"<p>Database class collection access follows this protocol when delegating to MasterIndex:</p> <pre><code>// 1. Database.getCollection() or Database.createCollection() delegates to MasterIndex\n// 2. Acquire virtual lock for thread safety\nconst acquired = masterIndex.acquireLock('users', operationId);\n\n// 3. Check for conflicts (if updating existing collection)\nconst hasConflict = masterIndex.hasConflict('users', expectedToken);\n\n// 4. Perform operations (Database coordinates with Drive operations)\n// 5. Update metadata with new modification token\nmasterIndex.updateCollectionMetadata('users', updates);\n\n// 6. Release lock\nmasterIndex.releaseLock('users', operationId);\n</code></pre>"},{"location":"developers/MasterIndex/#virtual-locking","title":"Virtual Locking","text":"<p>Prevents concurrent modifications across script instances:</p> <ul> <li>Locks expire automatically (default: 30 seconds)</li> <li>Operation ID required for lock acquisition/release</li> <li>Expired locks are cleaned up automatically</li> </ul>"},{"location":"developers/MasterIndex/#data-structure","title":"Data Structure","text":"<pre><code>{\n  version: Number,\n  lastUpdated: String,\n  collections: {\n    [collectionName]: {\n      name: String,\n      fileId: String | null,\n      created: String,\n      lastModified: String,\n      documentCount: Number,\n      modificationToken: String,\n      lockStatus: null | { lockedBy: String, lockedAt: String, expiresAt: String }\n    }\n  },\n  locks: {\n    [collectionName]: { lockedBy: String, lockedAt: String, expiresAt: String }\n  }\n}\n</code></pre>"},{"location":"developers/MasterIndex/#constructor","title":"Constructor","text":"<pre><code>class MasterIndex {\n  constructor(config = {}) {\n    // ...\n  }\n}\n</code></pre> <p>Parameters:</p> <ul> <li><code>config.masterIndexKey</code> (String): ScriptProperties key (default: 'GASDB_MASTER_INDEX')</li> <li><code>config.lockTimeout</code> (Number): Lock timeout in ms (default: 30000)</li> <li><code>config.version</code> (Number): Master index version (default: 1)</li> </ul> <p>Behaviour: Creates configuration, initialises data structure, loads from ScriptProperties if available.</p>"},{"location":"developers/MasterIndex/#api-reference","title":"API Reference","text":""},{"location":"developers/MasterIndex/#core-methods","title":"Core Methods","text":""},{"location":"developers/MasterIndex/#addcollectionname-metadata","title":"<code>addCollection(name, metadata)</code>","text":"<p>Adds collection to master index. Called by <code>Database.createCollection()</code> during collection creation.</p> <ul> <li><code>name</code> (String): Collection name</li> <li><code>metadata</code> (Object): Collection metadata (fileId, documentCount, etc.)</li> <li>Returns: Collection data object</li> <li>Throws: <code>CONFIGURATION_ERROR</code> for invalid name</li> <li>Database Integration: Primary method used by Database class to register new collections</li> </ul>"},{"location":"developers/MasterIndex/#getcollectionname-getcollections","title":"<code>getCollection(name)</code> / <code>getCollections()</code>","text":"<p>Retrieves collection metadata. Used by <code>Database.getCollection()</code> and <code>Database.listCollections()</code> to access collection information.</p> <ul> <li>Returns: Collection object or collections map</li> <li>Database Integration: Called by Database class methods to check for existing collections before creation or access</li> </ul>"},{"location":"developers/MasterIndex/#updatecollectionmetadataname-updates","title":"<code>updateCollectionMetadata(name, updates)</code>","text":"<p>Updates collection metadata with new modification token.</p> <ul> <li><code>updates</code> (Object): Metadata changes</li> <li>Returns: Updated collection data</li> </ul>"},{"location":"developers/MasterIndex/#removecollectionname","title":"<code>removeCollection(name)</code>","text":"<p>Removes a collection from the master index. Called by <code>Database.dropCollection()</code> during collection deletion.</p> <ul> <li><code>name</code> (String): Collection name to remove</li> <li>Returns: Boolean - <code>true</code> if the collection was removed, <code>false</code> otherwise</li> <li>Database Integration: Used by Database class to remove collections from the primary metadata store</li> </ul>"},{"location":"developers/MasterIndex/#getcollections","title":"<code>getCollections()</code>","text":"<p>Retrieves all collections in the master index.</p> <ul> <li>Returns: Object - map of collection metadata</li> </ul>"},{"location":"developers/MasterIndex/#locking-methods","title":"Locking Methods","text":""},{"location":"developers/MasterIndex/#acquirelockcollectionname-operationid","title":"<code>acquireLock(collectionName, operationId)</code>","text":"<p>Acquires virtual lock for collection. Used by Database class before performing collection operations.</p> <ul> <li>Returns: <code>true</code> if successful, <code>false</code> if already locked</li> <li>Database Integration: Called by Database methods during collection creation, modification, and deletion</li> </ul>"},{"location":"developers/MasterIndex/#releaselockcollectionname-operationid","title":"<code>releaseLock(collectionName, operationId)</code>","text":"<p>Releases virtual lock (must match operation ID).</p>"},{"location":"developers/MasterIndex/#islockedcollectionname","title":"<code>isLocked(collectionName)</code>","text":"<p>Checks if collection is currently locked.</p>"},{"location":"developers/MasterIndex/#cleanupexpiredlocks","title":"<code>cleanupExpiredLocks()</code>","text":"<p>Removes expired locks.</p>"},{"location":"developers/MasterIndex/#conflict-management","title":"Conflict Management","text":""},{"location":"developers/MasterIndex/#hasconflictcollectionname-expectedtoken","title":"<code>hasConflict(collectionName, expectedToken)</code>","text":"<p>Checks if collection was modified since token was generated.</p>"},{"location":"developers/MasterIndex/#resolveconflictcollectionname-newdata-strategy","title":"<code>resolveConflict(collectionName, newData, strategy)</code>","text":"<p>Resolves conflicts using specified strategy ('LAST_WRITE_WINS').</p>"},{"location":"developers/MasterIndex/#generatemodificationtoken","title":"<code>generateModificationToken()</code>","text":"<p>Creates unique modification token.</p>"},{"location":"developers/MasterIndex/#validatemodificationtokentoken","title":"<code>validateModificationToken(token)</code>","text":"<p>Validates token format (timestamp-randomstring).</p>"},{"location":"developers/MasterIndex/#usage-examples","title":"Usage Examples","text":""},{"location":"developers/MasterIndex/#basic-operations","title":"Basic Operations","text":"<pre><code>// Typically called via Database class, not directly\nconst masterIndex = new MasterIndex();\n\n// Database.createCollection() triggers this workflow:\nconst collection = masterIndex.addCollection('users', {\n  fileId: 'abc123',\n  documentCount: 0\n});\n\n// Database.getCollection() and Database.listCollections() use:\nconst users = masterIndex.getCollection('users');\n\n// Collection operations trigger metadata updates:\nmasterIndex.updateCollectionMetadata('users', {\n  documentCount: 5\n});\n</code></pre>"},{"location":"developers/MasterIndex/#locking-pattern","title":"Locking Pattern","text":"<pre><code>const operationId = 'op_' + Date.now();\n\nif (masterIndex.acquireLock('users', operationId)) {\n  try {\n    // Perform operations\n    masterIndex.updateCollectionMetadata('users', updates);\n  } finally {\n    masterIndex.releaseLock('users', operationId);\n  }\n}\n</code></pre>"},{"location":"developers/MasterIndex/#conflict-resolution","title":"Conflict Resolution","text":"<pre><code>const expectedToken = 'previously-read-token';\n\nif (masterIndex.hasConflict('users', expectedToken)) {\n  const resolution = masterIndex.resolveConflict('users', newData, 'LAST_WRITE_WINS');\n} else {\n  masterIndex.updateCollectionMetadata('users', newData);\n}\n</code></pre>"},{"location":"developers/MasterIndex/#integration-with-database-class","title":"Integration with Database Class","text":"<p>The <code>MasterIndex</code> serves as the primary source of truth for collection metadata, working closely with the <code>Database</code> class in the following ways:</p>"},{"location":"developers/MasterIndex/#collection-lifecycle-integration","title":"Collection Lifecycle Integration","text":"<p>Creation Flow:</p> <ol> <li><code>Database.createCollection()</code> validates collection name</li> <li>Database creates Drive file for collection data</li> <li>Database calls <code>MasterIndex.addCollection()</code> to register metadata</li> <li>Database updates Drive-based index file as backup</li> <li>Database caches collection object in memory</li> </ol> <p>Access Flow:</p> <ol> <li><code>Database.getCollection()</code> checks in-memory cache first</li> <li>If not cached, Database calls <code>MasterIndex.getCollection()</code></li> <li>If not in MasterIndex, Database falls back to Drive index file</li> <li>Auto-creation triggers if enabled and collection doesn't exist</li> </ol> <p>Deletion Flow:</p> <ol> <li><code>Database.dropCollection()</code> removes from memory cache</li> <li>Database calls <code>MasterIndex.removeCollection()</code> to update metadata</li> <li>Database deletes Drive file and updates index file</li> </ol>"},{"location":"developers/MasterIndex/#data-synchronisation","title":"Data Synchronisation","text":"<p>The Database class maintains consistency between MasterIndex and Drive-based storage:</p> <ul> <li>Primary Operations: MasterIndex handles all metadata operations</li> <li>Backup Operations: Database synchronises to Drive index file via <code>backupIndexToDrive()</code></li> <li>Recovery Operations: Database can restore from Drive index to MasterIndex if needed</li> </ul>"},{"location":"developers/MasterIndex/#locking-coordination","title":"Locking Coordination","text":"<p>Database class uses MasterIndex locking for thread safety:</p> <pre><code>// Example from Database.createCollection()\nconst operationId = 'create_' + Date.now();\nif (this._masterIndex.acquireLock(name, operationId)) {\n  try {\n    // Perform Drive operations\n    const driveFileId = this._fileService.createFile(fileName, data, folderId);\n    // Update MasterIndex\n    this._masterIndex.addCollection(name, { fileId: driveFileId });\n  } finally {\n    this._masterIndex.releaseLock(name, operationId);\n  }\n}\n</code></pre>"},{"location":"developers/MasterIndex/#error-types","title":"Error Types","text":"<ul> <li><code>CONFIGURATION_ERROR</code>: Invalid parameters</li> <li><code>COLLECTION_NOT_FOUND</code>: Collection doesn't exist</li> <li><code>LOCK_TIMEOUT</code>: Failed to acquire ScriptLock</li> <li><code>MASTER_INDEX_ERROR</code>: General operation failures</li> </ul>"},{"location":"developers/MasterIndex/#best-practices","title":"Best Practices","text":"<ol> <li>Always release locks in finally blocks</li> <li>Use appropriate timeouts for lock operations</li> <li>Handle lock acquisition failures with retry logic</li> <li>Validate modification tokens before updates</li> <li>Clean up expired locks periodically</li> </ol>"},{"location":"developers/QueryEngine/","title":"QueryEngine Developer Documentation","text":"<ul> <li>QueryEngine Developer Documentation</li> <li>Overview</li> <li>Core Principles</li> <li>API Reference<ul> <li><code>constructor(config)</code></li> <li><code>executeQuery(documents, query)</code></li> <li><code>_matchDocument(document, query)</code></li> <li><code>_matchField(document, fieldPath, queryValue)</code></li> <li><code>_getFieldValue(document, fieldPath)</code></li> <li><code>_isOperatorObject(value)</code></li> <li><code>_matchOperators(documentValue, operators)</code></li> <li>Shared Comparison Utilities</li> <li><code>_validateQuery(documents, query)</code></li> <li><code>_validateQueryInputs(documents, query)</code></li> <li><code>_validateQueryDepth(obj, depth)</code></li> <li><code>_validateOperators(query)</code></li> <li><code>_findOperators(obj, operators)</code></li> <li><code>_validateOperatorValues(query)</code></li> <li><code>_validateOperatorValuesRecursive(obj, depth)</code></li> <li><code>_matchLogicalAnd(document, conditions)</code></li> <li><code>_matchLogicalOr(document, conditions)</code></li> </ul> </li> <li>Supported Query Operators<ul> <li>Currently Supported Operators</li> </ul> </li> <li>Usage Examples<ul> <li>Simple Equality Match</li> <li>Using Comparison Operators</li> <li>Using Logical Operators</li> <li>Querying Nested Fields</li> <li>Querying Array Fields</li> <li>Future Array Operators (Not Yet Implemented)</li> </ul> </li> <li>Error Handling</li> <li>Query Validation System<ul> <li>Input Validation</li> <li>Structure Validation</li> <li>Security Features</li> <li>Validation Process</li> </ul> </li> <li>Best Practices</li> </ul>"},{"location":"developers/QueryEngine/#overview","title":"Overview","text":"<p>The <code>QueryEngine</code> class is responsible for filtering a list of documents based on a MongoDB-style query object. It evaluates documents against query criteria, supporting a variety of comparison, logical, and element operators.</p> <p>Key Responsibilities:</p> <ul> <li>Parsing and validating query objects.</li> <li>Matching documents against complex query criteria.</li> <li>Supporting nested field queries using dot notation.</li> <li>Handling various data types and operators.</li> </ul> <p>Dependencies:</p> <ul> <li><code>InvalidQueryError</code> and <code>InvalidArgumentError</code>: For standardised error reporting.</li> <li><code>Validate</code>: For input validation and type checking.</li> <li><code>JDbLogger</code>: For component logging and debugging.</li> </ul>"},{"location":"developers/QueryEngine/#core-principles","title":"Core Principles","text":"<ul> <li>MongoDB-like Syntax: The query language closely mirrors MongoDB's query syntax for familiarity and ease of use.</li> <li>Read-Only Operations: The engine only filters documents; it does not modify them.</li> <li>Extensibility: Designed to allow for the addition of new query operators.</li> <li>Performance Considerations: While aiming for comprehensive functionality, it's mindful of the Google Apps Script environment's limitations.</li> </ul>"},{"location":"developers/QueryEngine/#api-reference","title":"API Reference","text":""},{"location":"developers/QueryEngine/#constructorconfig","title":"<code>constructor(config)</code>","text":"<p>Creates a new <code>QueryEngine</code> instance with optional configuration.</p> <p>Parameters:</p> <ul> <li><code>config</code> (Object, optional): Configuration object with the following optional properties:</li> <li><code>maxNestedDepth</code> (Number): Maximum allowed query nesting depth (defaults to 10)</li> <li><code>supportedOperators</code> (String[]): Operators permitted by the engine (defaults to DatabaseConfig settings)</li> <li><code>logicalOperators</code> (String[]): Logical operators permitted by the engine (defaults to DatabaseConfig settings)</li> </ul> <p>Example:</p> <pre><code>// Default configuration (uses DatabaseConfig defaults)\nconst queryEngine = new QueryEngine();\n\n// Custom configuration\nconst queryEngine = new QueryEngine({\n  maxNestedDepth: 5,\n  supportedOperators: ['$eq', '$gt'],\n  logicalOperators: ['$and']\n});\n</code></pre>"},{"location":"developers/QueryEngine/#executequerydocuments-query","title":"<code>executeQuery(documents, query)</code>","text":"<p>Filters an array of documents based on the provided query object.</p> <p>Parameters:</p> <ul> <li><code>documents</code> (Array\\"},{"location":"developers/QueryEngine/#_matchdocumentdocument-query","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_matchfielddocument-fieldpath-queryvalue","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_getfieldvaluedocument-fieldpath","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_isoperatorobjectvalue","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_matchoperatorsdocumentvalue-operators","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#shared-comparison-utilities","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_validatequerydocuments-query","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_validatequeryinputsdocuments-query","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_validatequerydepthobj-depth","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_validateoperatorsquery","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_findoperatorsobj-operators","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_validateoperatorvaluesquery","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_validateoperatorvaluesrecursiveobj-depth","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_matchlogicalanddocument-conditions","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#_matchlogicalordocument-conditions","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#supported-query-operators","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#currently-supported-operators","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#usage-examples","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#simple-equality-match","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#using-comparison-operators","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#using-logical-operators","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#querying-nested-fields","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#querying-array-fields","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#future-array-operators-not-yet-implemented","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#error-handling","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#query-validation-system","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#input-validation","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#structure-validation","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#security-features","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#validation-process","title":"QueryEngine","text":""},{"location":"developers/QueryEngine/#best-practices","title":"QueryEngine","text":""},{"location":"developers/Testing_Framework/","title":"Testing Framework Developer Documentation","text":"<ul> <li>Testing Framework Developer Documentation</li> <li>Overview</li> <li>Key Features</li> <li>Framework Architecture</li> <li>Test Suite Structure and Best Practices</li> <li>Getting Started<ul> <li>Directory Structure</li> <li>Configuration</li> <li>GAS Mock Setup</li> </ul> </li> <li>Writing Tests<ul> <li>Basic Test Example</li> <li>Test with Setup and Cleanup</li> <li>Test with Helper Functions</li> <li>Error Testing</li> </ul> </li> <li>GAS Mocks<ul> <li>DriveApp</li> <li>Folder</li> <li>File</li> <li>PropertiesService</li> <li>LockService</li> <li>Utilities</li> <li>Logger</li> <li>MimeType</li> </ul> </li> <li>Helper Functions<ul> <li>Database Helpers</li> <li>Collection Helpers</li> <li>MasterIndex Helpers</li> </ul> </li> <li>Running Tests<ul> <li>Run All Tests</li> <li>Watch Mode</li> <li>Run Specific Test File</li> <li>Run Tests Matching Pattern</li> <li>Coverage</li> </ul> </li> <li>API Reference<ul> <li>Vitest Core APIs</li> <li>Test Structure</li> <li>Assertions<ul> <li>Equality</li> <li>Truthiness</li> <li>Numbers</li> <li>Strings</li> <li>Arrays/Iterables</li> <li>Objects</li> <li>Exceptions</li> </ul> </li> <li>Mocking (if needed)</li> <li>GAS Mock APIs</li> </ul> </li> </ul>"},{"location":"developers/Testing_Framework/#overview","title":"Overview","text":"<p>The JsonDbApp testing framework uses Vitest with realistic Google Apps Script (GAS) API mocks to provide fast, reliable unit testing in a local Node.js environment. Tests run against realistic implementations of DriveApp, PropertiesService, LockService and other GAS APIs that write to disk, ensuring high-fidelity test behaviour without requiring deployment to the Apps Script platform.</p>"},{"location":"developers/Testing_Framework/#key-features","title":"Key Features","text":"<ul> <li>Vitest-based: Modern, fast test runner with excellent DX</li> <li>Realistic GAS Mocks: Local implementations of DriveApp, PropertiesService, LockService, Utilities that persist to disk</li> <li>TDD-Ready: Red-Green-Refactor workflow with watch mode support</li> <li>Isolated Test Environment: Each test uses isolated ScriptProperties keys and Drive folders</li> <li>Comprehensive Assertions: Vitest's built-in matchers plus custom helpers</li> <li>Lifecycle Hooks: <code>beforeEach</code>, <code>afterEach</code>, <code>beforeAll</code>, <code>afterAll</code> for setup and teardown</li> <li>Resource Cleanup: Automatic tracking and cleanup of test artefacts</li> </ul>"},{"location":"developers/Testing_Framework/#framework-architecture","title":"Framework Architecture","text":"<p>The testing framework consists of several layers:</p> <ul> <li>Vitest: Test runner and assertion library</li> <li>GAS Mocks (tools/gas-mocks/): Node.js implementations of Google Apps Script APIs</li> <li>Setup Files (tests/setup/): Bootstrap GAS mocks and load legacy source files</li> <li>Test Helpers (tests/helpers/): Reusable setup, teardown, and utility functions</li> <li>Test Suites (tests/unit/): Organised test files by component</li> </ul>"},{"location":"developers/Testing_Framework/#test-suite-structure-and-best-practices","title":"Test Suite Structure and Best Practices","text":"<p>All tests follow a consistent, modular structure:</p> <ul> <li>One feature per file: Each test file focuses on a specific component or feature (e.g., MasterIndex.test.js, database-collection-management.test.js)</li> <li>Descriptive test names: Use <code>describe()</code> blocks to group related tests and <code>it()</code> for individual test cases</li> <li>Arrange-Act-Assert: Each test should clearly separate setup, execution, and assertions</li> <li>Lifecycle hooks: Use <code>beforeEach</code> and <code>afterEach</code> for resource management and isolation</li> <li>Descriptive assertions: Use Vitest's <code>expect()</code> with clear matcher names</li> <li>No side effects: Always clean up files, folders, and ScriptProperties, even on failure</li> <li>Red-Green-Refactor: Write failing tests first, then minimal passing code, then refactor</li> <li>Coverage: Include tests for constructor validation, configuration, happy paths, error cases, edge cases, and resource cleanup</li> </ul> <p>Example test structure:</p> <pre><code>import { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { setupComponent, cleanupComponent } from '../helpers/component-test-helpers.js';\n\ndescribe('Component Feature', () =&gt; {\n  let component;\n\n  beforeEach(() =&gt; {\n    component = setupComponent();\n  });\n\n  afterEach(() =&gt; {\n    cleanupComponent(component);\n  });\n\n  it('should perform expected behaviour', () =&gt; {\n    // Arrange\n    const input = { value: 42 };\n\n    // Act\n    const result = component.process(input);\n\n    // Assert\n    expect(result.value).toBe(42);\n    expect(result.processed).toBe(true);\n  });\n});\n</code></pre>"},{"location":"developers/Testing_Framework/#getting-started","title":"Getting Started","text":""},{"location":"developers/Testing_Framework/#directory-structure","title":"Directory Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 vitest.config.js           # Vitest configuration\n\u251c\u2500\u2500 setup/\n\u2502   \u2514\u2500\u2500 gas-mocks.setup.js     # Bootstraps GAS mocks and loads source files\n\u251c\u2500\u2500 helpers/\n\u2502   \u251c\u2500\u2500 database-test-helpers.js\n\u2502   \u251c\u2500\u2500 collection-test-helpers.js\n\u2502   \u2514\u2500\u2500 ...                    # Reusable test utilities\n\u251c\u2500\u2500 unit/\n\u2502   \u251c\u2500\u2500 master-index/\n\u2502   \u251c\u2500\u2500 database/\n\u2502   \u251c\u2500\u2500 validation/\n\u2502   \u2514\u2500\u2500 ...                    # Component-specific test suites\n\u2514\u2500\u2500 .gas-drive/                # Mock Drive storage (gitignored)\n\u2514\u2500\u2500 .gas-script-properties.json # Mock ScriptProperties (gitignored)\n</code></pre>"},{"location":"developers/Testing_Framework/#configuration","title":"Configuration","text":"<p>The Vitest configuration (tests/vitest.config.js) sets up:</p> <ul> <li>Test environment (Node.js)</li> <li>Setup files (GAS mocks)</li> <li>Test file patterns (<code>unit/**/*.test.js</code>, <code>helpers/**/*.test.js</code>)</li> <li>Mock cleanup behaviour</li> </ul>"},{"location":"developers/Testing_Framework/#gas-mock-setup","title":"GAS Mock Setup","text":"<p>The setup file (tests/setup/gas-mocks.setup.js):</p> <ol> <li>Creates GAS mock instances with isolated storage paths</li> <li>Injects mocks into global scope (<code>DriveApp</code>, <code>PropertiesService</code>, etc.)</li> <li>Loads legacy source files into the test context using <code>vm.runInThisContext()</code></li> </ol>"},{"location":"developers/Testing_Framework/#writing-tests","title":"Writing Tests","text":""},{"location":"developers/Testing_Framework/#basic-test-example","title":"Basic Test Example","text":"<pre><code>import { describe, it, expect } from 'vitest';\n\ndescribe('IdGenerator', () =&gt; {\n  it('should generate unique IDs', () =&gt; {\n    const generator = new IdGenerator();\n    const id1 = generator.generateId();\n    const id2 = generator.generateId();\n\n    expect(id1).toBeDefined();\n    expect(id2).toBeDefined();\n    expect(id1).not.toBe(id2);\n  });\n});\n</code></pre>"},{"location":"developers/Testing_Framework/#test-with-setup-and-cleanup","title":"Test with Setup and Cleanup","text":"<pre><code>import { describe, it, expect, afterEach } from 'vitest';\n\nconst scriptProperties = PropertiesService.getScriptProperties();\nconst trackedKeys = new Set();\n\nconst registerKey = (key) =&gt; {\n  trackedKeys.add(key);\n  return key;\n};\n\nafterEach(() =&gt; {\n  for (const key of trackedKeys) {\n    scriptProperties.deleteProperty(key);\n  }\n  trackedKeys.clear();\n});\n\ndescribe('MasterIndex Persistence', () =&gt; {\n  it('should persist to ScriptProperties', () =&gt; {\n    const key = registerKey(`TEST_KEY_${Date.now()}`);\n    const masterIndex = new MasterIndex({ masterIndexKey: key });\n\n    const stored = scriptProperties.getProperty(key);\n    expect(stored).toBeDefined();\n    expect(typeof stored).toBe('string');\n  });\n});\n</code></pre>"},{"location":"developers/Testing_Framework/#test-with-helper-functions","title":"Test with Helper Functions","text":"<p>Database Test Helpers Example:</p> <pre><code>import { describe, it, expect } from 'vitest';\nimport {\n  setupInitialisedDatabase,\n  generateUniqueName,\n  registerDatabaseFile\n} from '../../helpers/database-test-helpers.js';\n\ndescribe('Database Collection Management', () =&gt; {\n  it('should create a new collection', () =&gt; {\n    const { database } = setupInitialisedDatabase();\n    const name = generateUniqueName('testCollection');\n\n    const collection = database.createCollection(name);\n    registerDatabaseFile(collection.driveFileId);\n\n    expect(collection.name).toBe(name);\n    expect(database.listCollections()).toContain(name);\n  });\n});\n</code></pre> <p>Collection Test Helpers Example:</p> <pre><code>import { describe, it, expect } from 'vitest';\nimport {\n  createIsolatedTestCollection,\n  seedStandardEmployees,\n  assertAcknowledgedWrite\n} from '../../helpers/collection-test-helpers.js';\n\ndescribe('Collection Delete Operations', () =&gt; {\n  it('should delete a document by ID', () =&gt; {\n    // Arrange\n    const { collection } = createIsolatedTestCollection('deleteTest');\n    const { aliceId } = seedStandardEmployees(collection);\n\n    // Act\n    const result = collection.deleteOne({ _id: aliceId });\n\n    // Assert\n    assertAcknowledgedWrite(result, { deletedCount: 1 });\n    expect(collection.findOne({ _id: aliceId })).toBeNull();\n  });\n});\n</code></pre>"},{"location":"developers/Testing_Framework/#error-testing","title":"Error Testing","text":"<pre><code>describe('Error Handling', () =&gt; {\n  it('should throw InvalidArgumentError for invalid input', () =&gt; {\n    const { database } = setupInitialisedDatabase({ autoCreateCollections: false });\n    const missingName = generateUniqueName('missing');\n\n    expect(() =&gt; database.getCollection(missingName)).toThrowError(/auto-create is disabled/);\n  });\n});\n</code></pre>"},{"location":"developers/Testing_Framework/#gas-mocks","title":"GAS Mocks","text":"<p>The GAS mocks (tools/gas-mocks/gas-mocks.cjs) provide realistic implementations of:</p>"},{"location":"developers/Testing_Framework/#driveapp","title":"DriveApp","text":"<ul> <li><code>createFolder(name)</code>: Creates folder on disk</li> <li><code>getFolderById(id)</code>: Retrieves folder by ID</li> <li><code>getFileById(id)</code>: Retrieves file by ID</li> <li><code>getRootFolder()</code>: Returns singleton root folder</li> </ul>"},{"location":"developers/Testing_Framework/#folder","title":"Folder","text":"<ul> <li><code>createFile(name, content, mimeType)</code>: Writes file to disk</li> <li><code>getFiles()</code>: Returns FileIterator</li> <li><code>getFoldersByName(name)</code>: Returns FolderIterator</li> <li><code>setTrashed(trashed)</code>: Marks folder as deleted</li> </ul>"},{"location":"developers/Testing_Framework/#file","title":"File","text":"<ul> <li><code>getName()</code>, <code>getId()</code>, <code>getMimeType()</code>: Metadata accessors</li> <li><code>getBlob()</code>: Returns Blob with <code>getDataAsString()</code></li> <li><code>setContent(content)</code>: Updates file content on disk</li> <li><code>setTrashed(trashed)</code>: Marks file as deleted</li> </ul>"},{"location":"developers/Testing_Framework/#propertiesservice","title":"PropertiesService","text":"<ul> <li><code>getScriptProperties()</code>: Returns singleton Properties instance</li> <li>Properties: <code>getProperty(key)</code>, <code>setProperty(key, value)</code>, <code>deleteProperty(key)</code></li> <li>Backed by JSON file on disk</li> </ul>"},{"location":"developers/Testing_Framework/#lockservice","title":"LockService","text":"<ul> <li><code>getScriptLock()</code>: Returns singleton Lock instance</li> <li>Lock: <code>waitLock(timeout)</code>, <code>releaseLock()</code></li> <li>Note: Uses busy-wait, suitable for single-threaded sequential tests only</li> </ul>"},{"location":"developers/Testing_Framework/#utilities","title":"Utilities","text":"<ul> <li><code>sleep(milliseconds)</code>: Blocking sleep</li> </ul>"},{"location":"developers/Testing_Framework/#logger","title":"Logger","text":"<ul> <li><code>log(data)</code>: Forwards to console</li> </ul>"},{"location":"developers/Testing_Framework/#mimetype","title":"MimeType","text":"<ul> <li><code>PLAIN_TEXT</code>: <code>\"text/plain\"</code></li> <li><code>JSON</code>: <code>\"application/json\"</code></li> </ul> <p>Configuration:</p> <pre><code>const mocks = createGasMocks({\n  driveRoot: '/tmp/gasdb-drive', // Where Drive files are stored\n  propertiesFile: '/tmp/gasdb-props.json' // Where ScriptProperties are persisted\n});\n</code></pre>"},{"location":"developers/Testing_Framework/#helper-functions","title":"Helper Functions","text":"<p>Test helpers provide reusable setup and cleanup utilities:</p>"},{"location":"developers/Testing_Framework/#database-helpers","title":"Database Helpers","text":"<p>(tests/helpers/database-test-helpers.js)</p> <ul> <li><code>cleanupDatabaseTests()</code>: Removes Drive files and ScriptProperties keys created during Database tests</li> <li><code>createBackupIndexFile(rootFolderId, backupData, fileName)</code>: Creates a Drive backup file for recovery scenarios</li> <li><code>createDatabaseTestConfig(overrides)</code>: Builds isolated configuration objects for Database tests</li> <li><code>expectCollectionPersisted(databaseContext, collectionName, expectedMetadata)</code>: Verifies that a collection has been persisted to the MasterIndex with expected metadata (fileId, documentCount). Automatically registers the file for cleanup and instantiates MasterIndex for assertions</li> <li><code>generateUniqueName(prefix)</code>: Generates unique names for artefacts</li> <li><code>registerDatabaseFile(fileId)</code>: Tracks files for cleanup</li> <li><code>registerMasterIndexKey(masterIndexKey)</code>: Registers ScriptProperties keys for cleanup</li> <li><code>setupDatabaseTestEnvironment(overrides)</code>: Constructs Database instances with isolated storage</li> <li><code>setupInitialisedDatabase(overrides)</code>: Creates Database instances that already executed createDatabase() and initialise()</li> </ul>"},{"location":"developers/Testing_Framework/#collection-helpers","title":"Collection Helpers","text":"<p>(tests/helpers/collection-test-helpers.js)</p> <ul> <li><code>assertAcknowledgedWrite(result, expectedCounts)</code>: Validates MongoDB-style write results with optional count assertions (matchedCount, modifiedCount, deletedCount, insertedId)</li> <li><code>createIsolatedTestCollection(collectionName)</code>: Builds fresh environment and returns env, collection, and file ID</li> <li><code>createMasterIndexKey()</code>: Creates unique master index key with auto-cleanup</li> <li><code>createTestCollection(env, collectionName, options)</code>: Creates Collection instance with registration</li> <li><code>createTestCollectionFile(folderId, collectionName)</code>: Creates collection file</li> <li><code>createTestFileWithContent(folderId, fileName, content)</code>: Creates file with custom content</li> <li><code>createTestFolder()</code>: Creates test folder in mock Drive with auto-cleanup</li> <li><code>registerAndCreateCollection(env, collectionName, fileId, documentCount)</code>: Registers metadata and creates Collection</li> <li><code>seedStandardEmployees(collection)</code>: Seeds collection with standard employee test data (Alice, Bob, Charlie) and returns object containing insertedId values</li> <li><code>setupCollectionTestEnvironment()</code>: Complete environment setup (folder, master index, file service, database)</li> </ul>"},{"location":"developers/Testing_Framework/#documentoperations-helpers","title":"DocumentOperations Helpers","text":"<p>(tests/helpers/document-operations-test-helpers.js)</p> <ul> <li><code>createDocumentOperationsContext()</code>: Creates complete test context with env, docOps, and reload helper (replaces beforeEach setup)</li> <li><code>setupTestEnvironment()</code>: Sets up complete test environment for DocumentOperations tests (returns env with folderId, fileId, collection, logger)</li> <li><code>resetCollection(collection)</code>: Resets a collection to initial empty state</li> <li><code>createTestFolder()</code>: Creates a test folder in mock Drive with auto-cleanup</li> <li><code>createTestCollectionFile(folderId, collectionName)</code>: Creates a test collection file in the specified folder</li> <li><code>assertAcknowledgedResult(result, expectedCounts)</code>: Asserts that a DocumentOperations result is acknowledged and optionally checks modifiedCount/deletedCount</li> <li><code>cleanupTestResources()</code>: Cleanup function automatically registered with afterEach</li> </ul> <p>Usage Pattern:</p> <p>The <code>createDocumentOperationsContext()</code> helper simplifies test setup by providing a complete context in one call:</p> <pre><code>import { describe, it, expect, beforeEach } from 'vitest';\nimport { createDocumentOperationsContext } from '../../helpers/document-operations-test-helpers.js';\n\ndescribe('DocumentOperations Tests', () =&gt; {\n  let docOps, reload;\n\n  beforeEach(() =&gt; {\n    ({ docOps, reload } = createDocumentOperationsContext());\n  });\n\n  it('should insert and persist document', () =&gt; {\n    // Arrange\n    const testDoc = { name: 'Test User', email: 'test@example.com' };\n\n    // Act\n    const result = docOps.insertDocument(testDoc);\n\n    // Assert\n    expect(result._id).toBeDefined();\n    expect(result.name).toBe(testDoc.name);\n\n    // Verify persistence\n    const documents = reload();\n    const savedDoc = documents[result._id];\n    expect(savedDoc).toBeDefined();\n    expect(savedDoc.name).toBe(testDoc.name);\n  });\n});\n</code></pre> <p>The <code>reload()</code> helper function (returned by <code>createDocumentOperationsContext()</code>) reloads collection data from disk and returns the current documents object, making it easy to verify persistence.</p>"},{"location":"developers/Testing_Framework/#validation-helpers","title":"Validation Helpers","text":"<p>(tests/helpers/validation-test-helpers.js)</p> <p>The <code>describeValidationOperatorSuite()</code> helper simplifies validation test setup by providing automatic environment setup and cleanup:</p> <pre><code>import { describe, it, expect } from 'vitest';\nimport { describeValidationOperatorSuite } from '../../helpers/validation-test-helpers.js';\n\ndescribeValidationOperatorSuite('$eq Equality Operator Tests', (getTestEnv) =&gt; {\n  describe('Basic equality matching', () =&gt; {\n    it('should match string values exactly', () =&gt; {\n      // Arrange\n      const testEnv = getTestEnv();\n      const collection = testEnv.collections.persons;\n\n      // Act\n      const results = collection.find({ 'name.first': { $eq: 'Anna' } });\n\n      // Assert\n      expect(results).toHaveLength(1);\n      expect(results[0]._id).toBe('person1');\n    });\n  });\n});\n</code></pre> <p>The <code>getTestEnv()</code> helper function (provided by <code>describeValidationOperatorSuite()</code>) retrieves the test environment with pre-populated collections and ValidationMockData, making it easy to test query and update operators.</p>"},{"location":"developers/Testing_Framework/#database-helpers_1","title":"Database Helpers","text":"<p>(tests/helpers/database-test-helpers.js)</p> <p>The <code>expectCollectionPersisted()</code> helper verifies that collections are properly persisted to the MasterIndex:</p> <pre><code>import { describe, it, expect } from 'vitest';\nimport {\n  setupInitialisedDatabase,\n  expectCollectionPersisted\n} from '../../helpers/database-test-helpers.js';\n\ndescribe('Database Collection Management', () =&gt; {\n  it('should persist collection to master index', () =&gt; {\n    // Arrange\n    const { database, ...databaseContext } = setupInitialisedDatabase();\n    const collectionName = 'users';\n\n    // Act\n    const collection = database.createCollection(collectionName);\n\n    // Assert\n    expectCollectionPersisted(databaseContext, collectionName, {\n      fileId: collection.driveFileId,\n      documentCount: 0\n    });\n  });\n});\n</code></pre> <p>The <code>expectCollectionPersisted()</code> helper automatically registers the file for cleanup, instantiates a fresh MasterIndex, and verifies all metadata properties.</p>"},{"location":"developers/Testing_Framework/#masterindex-helpers","title":"MasterIndex Helpers","text":"<p>(tests/helpers/master-index-test-helpers.js)</p> <ul> <li><code>cleanupMasterIndexTests()</code>: Deletes all registered ScriptProperties keys after each test</li> <li><code>createMasterIndexKey()</code>: Generates and registers a unique ScriptProperties key for tests</li> <li><code>createTestMasterIndex(config)</code>: Builds an isolated MasterIndex with automatic key tracking; accepts overrides such as <code>modificationHistoryLimit</code> so history trimming can be exercised deterministically</li> <li><code>registerMasterIndexKey(key)</code>: Adds an existing key to the tracked cleanup set</li> <li><code>seedMasterIndex(key, data)</code>: Serialises and stores master index payloads for fixtures; pair with CollectionMetadata instances when validating the metadata normaliser</li> </ul>"},{"location":"developers/Testing_Framework/#validation-helpers_1","title":"Validation Helpers","text":"<p>(tests/helpers/validation-test-helpers.js)</p> <ul> <li><code>cleanupValidationTests(env)</code>: Cleans up all validation test resources (files, folders, ScriptProperties)</li> <li><code>describeValidationOperatorSuite(description, callback)</code>: Creates a complete validation test suite with automatic setup/cleanup. Provides <code>getTestEnv()</code> function to access the test environment (database, collections, mock data)</li> <li><code>setupValidationTestEnvironment()</code>: Sets up a complete validation test environment with pre-populated collections and mock data</li> </ul> <p>When writing MasterIndex suites, prefer the public API so the internal helpers (MasterIndexMetadataNormaliser and MasterIndexHistoryManager) are exercised end to end. This ensures metadata cloning, timestamp coercion, and modification history capping mirror production behaviour. For example:</p> <pre><code>const { masterIndex } = createTestMasterIndex({ modificationHistoryLimit: 5 });\nmasterIndex.addCollection('users', { fileId: 'users-file' });\n\nfor (let i = 0; i &lt; 10; i += 1) {\n  masterIndex.updateCollectionMetadata('users', { documentCount: i });\n}\n\nconst history = masterIndex.getModificationHistory('users');\nexpect(history).toHaveLength(5);\n</code></pre> <p><code>DEFAULT_MODIFICATION_HISTORY_LIMIT</code> is exported alongside the MasterIndex facade; use it when you need to assert the fallback cap without overriding configuration.</p>"},{"location":"developers/Testing_Framework/#running-tests","title":"Running Tests","text":""},{"location":"developers/Testing_Framework/#run-all-tests","title":"Run All Tests","text":"<pre><code>npm run test\n</code></pre>"},{"location":"developers/Testing_Framework/#run-all-tests-verbose-output","title":"Run All Tests (Verbose Output)","text":"<pre><code>npm run test:verbose\n</code></pre>"},{"location":"developers/Testing_Framework/#watch-mode","title":"Watch Mode","text":"<pre><code>npm run test -- --watch\n</code></pre>"},{"location":"developers/Testing_Framework/#run-specific-test-file","title":"Run Specific Test File","text":"<pre><code>npm run test -- tests/unit/master-index/MasterIndex.test.js\n</code></pre>"},{"location":"developers/Testing_Framework/#run-tests-matching-pattern","title":"Run Tests Matching Pattern","text":"<pre><code>npm run test -- -t \"should persist\"\n</code></pre>"},{"location":"developers/Testing_Framework/#coverage","title":"Coverage","text":"<pre><code>npm run test -- --coverage\n</code></pre>"},{"location":"developers/Testing_Framework/#api-reference","title":"API Reference","text":""},{"location":"developers/Testing_Framework/#vitest-core-apis","title":"Vitest Core APIs","text":""},{"location":"developers/Testing_Framework/#test-structure","title":"Test Structure","text":"<ul> <li><code>describe(name, fn)</code>: Groups related tests</li> <li><code>it(name, fn)</code> / <code>test(name, fn)</code>: Defines individual test</li> <li><code>beforeEach(fn)</code>: Runs before each test in scope</li> <li><code>afterEach(fn)</code>: Runs after each test in scope</li> <li><code>beforeAll(fn)</code>: Runs once before all tests in scope</li> <li><code>afterAll(fn)</code>: Runs once after all tests in scope</li> </ul>"},{"location":"developers/Testing_Framework/#assertions","title":"Assertions","text":"<p>Vitest uses <code>expect()</code> with matchers:</p>"},{"location":"developers/Testing_Framework/#equality","title":"Equality","text":"<ul> <li><code>expect(value).toBe(expected)</code>: Strict equality (===)</li> <li><code>expect(value).toEqual(expected)</code>: Deep equality</li> <li><code>expect(value).not.toBe(expected)</code>: Negation</li> </ul>"},{"location":"developers/Testing_Framework/#truthiness","title":"Truthiness","text":"<ul> <li><code>expect(value).toBeTruthy()</code>: Truthy value</li> <li><code>expect(value).toBeFalsy()</code>: Falsy value</li> <li><code>expect(value).toBeDefined()</code>: Not undefined</li> <li><code>expect(value).toBeUndefined()</code>: Undefined</li> <li><code>expect(value).toBeNull()</code>: Null</li> </ul>"},{"location":"developers/Testing_Framework/#numbers","title":"Numbers","text":"<ul> <li><code>expect(value).toBeGreaterThan(n)</code></li> <li><code>expect(value).toBeLessThan(n)</code></li> <li><code>expect(value).toBeCloseTo(n, precision)</code></li> </ul>"},{"location":"developers/Testing_Framework/#strings","title":"Strings","text":"<ul> <li><code>expect(string).toMatch(pattern)</code>: Regex or substring match</li> <li><code>expect(string).toContain(substring)</code></li> </ul>"},{"location":"developers/Testing_Framework/#arraysiterables","title":"Arrays/Iterables","text":"<ul> <li><code>expect(array).toContain(item)</code></li> <li><code>expect(array).toHaveLength(n)</code></li> <li><code>expect(array).toEqual(expect.arrayContaining([...]))</code></li> </ul>"},{"location":"developers/Testing_Framework/#objects","title":"Objects","text":"<ul> <li><code>expect(obj).toHaveProperty(key, value)</code></li> <li><code>expect(obj).toMatchObject(subset)</code></li> <li><code>expect(obj).toBeInstanceOf(Class)</code></li> </ul>"},{"location":"developers/Testing_Framework/#exceptions","title":"Exceptions","text":"<ul> <li><code>expect(() =&gt; fn()).toThrow()</code>: Throws any error</li> <li><code>expect(() =&gt; fn()).toThrow(ErrorClass)</code>: Throws specific error type</li> <li><code>expect(() =&gt; fn()).toThrowError(message)</code>: Throws with message matching string/regex</li> </ul>"},{"location":"developers/Testing_Framework/#mocking-if-needed","title":"Mocking (if needed)","text":"<ul> <li><code>vi.fn()</code>: Creates mock function</li> <li><code>vi.spyOn(object, 'method')</code>: Spies on method</li> <li><code>vi.mock(path)</code>: Mocks module</li> </ul>"},{"location":"developers/Testing_Framework/#gas-mock-apis","title":"GAS Mock APIs","text":"<p>See GAS Mocks Plan for complete method signatures and data shapes.</p>"},{"location":"developers/UpdateEngine/","title":"UpdateEngine Developer Documentation","text":"<ul> <li>UpdateEngine Developer Documentation</li> <li>Overview</li> <li>Core Principles</li> <li>API Reference<ul> <li><code>constructor()</code></li> <li><code>applyOperators(document, updateOps)</code></li> <li>Private Operator Handlers</li> <li><code>_applySet(document, ops)</code></li> <li><code>_applyInc(document, ops)</code></li> <li><code>_applyMul(document, ops)</code></li> <li><code>_applyMin(document, ops)</code></li> <li><code>_applyMax(document, ops)</code></li> <li><code>_applyUnset(document, ops)</code></li> <li><code>_applyPush(document, ops)</code></li> <li><code>_applyPull(document, ops)</code></li> </ul> </li> <li><code>_applyAddToSet(document, ops)</code></li> <li><code>$each</code> Modifier in Array Operators`</li> <li>Shared Comparison Utilities<ul> <li>Utility Methods</li> <li><code>_getFieldValue(document, fieldPath)</code></li> <li><code>_setFieldValue(document, fieldPath, value)</code></li> </ul> </li> <li>Usage Examples<ul> <li>Applying Multiple Operators</li> <li>Updating Nested Fields</li> <li>Array Manipulations</li> </ul> </li> <li>Error Handling<ul> <li>Private Validation Methods</li> </ul> </li> <li>Best Practices<ul> <li>Dot Notation and Nested Paths</li> </ul> </li> </ul>"},{"location":"developers/UpdateEngine/#overview","title":"Overview","text":"<p>The <code>UpdateEngine</code> class is responsible for applying MongoDB-style update operators to documents. It provides a robust mechanism for modifying documents based on a set of specified operations. This class is a key component in the document update process within GAS DB.</p> <p>Key Responsibilities:</p> <ul> <li>Parsing and validating update operator objects.</li> <li>Applying various update operators to in-memory document representations.</li> <li>Handling nested field updates and array manipulations.</li> <li>Ensuring data integrity during update operations.</li> </ul> <p>Dependencies:</p> <ul> <li><code>ErrorHandler</code>: For standardised error reporting.</li> <li><code>JDbLogger</code>: For component-level logging.</li> <li><code>ObjectUtils</code>: For deep cloning documents.</li> </ul>"},{"location":"developers/UpdateEngine/#core-principles","title":"Core Principles","text":"<p>The <code>UpdateEngine</code> adheres to the following design principles:</p> <ul> <li>Operator-based modifications: All changes to documents are driven by explicit update operators.</li> <li>Immutability (conceptual): While the provided document object is modified directly for performance reasons within the GAS environment, the conceptual model is that operators transform a document into a new state.</li> <li>Comprehensive operator support: Aims to support a wide range of MongoDB update operators.</li> <li>Error reporting: Provides clear error messages for invalid operations or data types.</li> </ul>"},{"location":"developers/UpdateEngine/#api-reference","title":"API Reference","text":""},{"location":"developers/UpdateEngine/#constructor","title":"<code>constructor()</code>","text":"<p>Creates a new <code>UpdateEngine</code> instance.</p> <pre><code>const updateEngine = new UpdateEngine();\n</code></pre>"},{"location":"developers/UpdateEngine/#applyoperatorsdocument-updateops","title":"<code>applyOperators(document, updateOps)</code>","text":"<p>Applies a set of MongoDB-style update operators to a given document. This is the main public method of the class.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to be modified.</li> <li><code>updateOps</code> (Object): An object specifying the update operations to apply. Keys are update operators (e.g., <code>$set</code>, <code>$inc</code>), and values are the operator-specific arguments.</li> </ul> <p>Returns:</p> <ul> <li><code>Object</code>: A deep clone of the original document, with the updates applied. The original document is not mutated.</li> </ul> <p>Throws:</p> <ul> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If the <code>updateOps</code> object is empty, contains no valid '$' prefixed operators, or if an unknown operator is encountered.</li> </ul> <p>Example:</p> <pre><code>const updateEngine = new UpdateEngine();\nlet doc = { name: 'Test Document', count: 10, tags: ['a', 'b'] };\nconst operations = {\n  $set: { name: 'Updated Document', status: 'active' },\n  $inc: { count: 5 },\n  $push: { tags: 'c' }\n};\n\ndoc = updateEngine.applyOperators(doc, operations);\n// doc is now:\n// { name: \"Updated Document\", count: 15, tags: [\"a\", \"b\", \"c\"], status: \"active\" }\n</code></pre>"},{"location":"developers/UpdateEngine/#private-operator-handlers","title":"Private Operator Handlers","text":"<p>These methods are called internally by <code>applyOperators</code> to handle specific update logic.</p>"},{"location":"developers/UpdateEngine/#_applysetdocument-ops","title":"<code>_applySet(document, ops)</code>","text":"<p>Sets the value of specified fields. If the field does not exist, it creates the field. This includes creating nested objects if the field path contains dot notation.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>ops</code> (Object): An object where keys are field paths (can be dot-notation for nested fields) and values are the new values for those fields.</li> </ul> <p>Returns:</p> <ul> <li><code>Object</code>: The modified document.</li> </ul> <p>Example:</p> <pre><code>// Assuming doc = { name: \"Test\" }\nupdateEngine._applySet(doc, { name: 'New Name', 'details.host': 'server1' });\n// doc is now: { name: \"New Name\", details: { host: \"server1\" } }\n</code></pre>"},{"location":"developers/UpdateEngine/#_applyincdocument-ops","title":"<code>_applyInc(document, ops)</code>","text":"<p>Increments the value of specified numeric fields by a given amount.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>ops</code> (Object): An object where keys are field paths and values are the amounts to increment by.</li> </ul> <p>Returns:</p> <ul> <li><code>Object</code>: The modified document.</li> </ul> <p>Throws:</p> <ul> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If a target field or increment value is non-numeric.</li> </ul> <p>Example:</p> <pre><code>// Assuming doc = { views: 100 }\nupdateEngine._applyInc(doc, { views: 10, 'metrics.downloads': 1 });\n// doc is now: { views: 110, metrics: { downloads: 1 } }\n</code></pre>"},{"location":"developers/UpdateEngine/#_applymuldocument-ops","title":"<code>_applyMul(document, ops)</code>","text":"<p>Multiplies the value of specified numeric fields by a given factor.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>ops</code> (Object): An object where keys are field paths and values are the multiplication factors.</li> </ul> <p>Returns:</p> <ul> <li><code>Object</code>: The modified document.</li> </ul> <p>Throws:</p> <ul> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If a target field or factor is non-numeric.</li> </ul> <p>Example:</p> <pre><code>// Assuming doc = { price: 10 }\nupdateEngine._applyMul(doc, { price: 1.2 });\n// doc is now: { price: 12 }\n</code></pre>"},{"location":"developers/UpdateEngine/#_applymindocument-ops","title":"<code>_applyMin(document, ops)</code>","text":"<p>Sets fields to the minimum of their current value and a provided value. Only updates if the new value is less than the existing value.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>ops</code> (Object): An object where keys are field paths and values are the values to compare against.</li> </ul> <p>Returns:</p> <ul> <li><code>Object</code>: The modified document.</li> </ul> <p>Throws:</p> <ul> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If a comparison between values is invalid (e.g., comparing a number to a string).</li> </ul> <p>Example:</p> <pre><code>// Assuming doc = { score: 100 }\nupdateEngine._applyMin(doc, { score: 90 }); // score becomes 90\nupdateEngine._applyMin(doc, { score: 95 }); // score remains 90\n</code></pre>"},{"location":"developers/UpdateEngine/#_applymaxdocument-ops","title":"<code>_applyMax(document, ops)</code>","text":"<p>Sets fields to the maximum of their current value and a provided value. Only updates if the new value is greater than the existing value.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>ops</code> (Object): An object where keys are field paths and values are the values to compare against.</li> </ul> <p>Returns:</p> <ul> <li><code>Object</code>: The modified document.</li> </ul> <p>Throws:</p> <ul> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If a comparison between values is invalid.</li> </ul> <p>Example:</p> <pre><code>// Assuming doc = { highScore: 200 }\nupdateEngine._applyMax(doc, { highScore: 250 }); // highScore becomes 250\nupdateEngine._applyMax(doc, { highScore: 240 }); // highScore remains 250\n</code></pre>"},{"location":"developers/UpdateEngine/#_applyunsetdocument-ops","title":"<code>_applyUnset(document, ops)</code>","text":"<p>Removes specified fields from a document.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>ops</code> (Object): An object where keys are field paths to remove. The values are typically <code>true</code> or <code>1</code> but are not strictly checked.</li> </ul> <p>Returns:</p> <ul> <li><code>Object</code>: The modified document.</li> </ul> <p>Example:</p> <pre><code>// Assuming doc = { name: \"Test\", temporary: true, \"config.old\": 1 }\nupdateEngine._applyUnset(doc, { temporary: '', 'config.old': true });\n// doc is now: { name: \"Test\", config: {} }\n</code></pre>"},{"location":"developers/UpdateEngine/#_applypushdocument-ops","title":"<code>_applyPush(document, ops)</code>","text":"<p>Appends a value to an array field. If the field does not exist, it creates an array field with the new value. If the field exists but is not an array, an error is thrown. Supports the <code>$each</code> modifier to append multiple values.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>ops</code> (Object): An object where keys are field paths. Values can be a single item to push or an object with an <code>$each</code> property containing an array of items to push.</li> </ul> <p>Returns:</p> <ul> <li><code>Object</code>: The modified document.</li> </ul> <p>Throws:</p> <ul> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If the target field is not an array (and exists), or if <code>$each</code> modifier is not an array.</li> </ul> <p>Example:</p> <pre><code>// Assuming doc = { tags: [\"alpha\"] }\nupdateEngine._applyPush(doc, { tags: 'beta' });\n// doc is now: { tags: [\"alpha\", \"beta\"] }\n\nupdateEngine._applyPush(doc, { tags: { $each: ['gamma', 'delta'] } });\n// doc is now: { tags: [\"alpha\", \"beta\", \"gamma\", \"delta\"] }\n</code></pre>"},{"location":"developers/UpdateEngine/#_applypulldocument-ops","title":"<code>_applyPull(document, ops)</code>","text":"<p>Removes all instances of specified values from an array field.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>ops</code> (Object): An object where keys are field paths and values are the items to remove from the array.</li> </ul> <p>Returns:</p> <ul> <li><code>Object</code>: The modified document.</li> </ul> <p>Throws:</p> <ul> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If the target field is not an array.</li> </ul> <p>Example:</p> <pre><code>// Assuming doc = { scores: [10, 20, 30, 20, 40] }\nupdateEngine._applyPull(doc, { scores: 20 });\n// doc is now: { scores: [10, 30, 40] }\n</code></pre>"},{"location":"developers/UpdateEngine/#_applyaddtosetdocument-ops","title":"<code>_applyAddToSet(document, ops)</code>","text":"<p>Adds values to an array field only if they are not already present. Supports the <code>$each</code> modifier.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>ops</code> (Object): An object where keys are field paths. Values can be a single item or an object with <code>$each</code>.</li> </ul> <p>Returns:</p> <ul> <li><code>Object</code>: The modified document.</li> </ul> <p>Throws:</p> <ul> <li><code>ErrorHandler.ErrorTypes.INVALID_QUERY</code>: If the target field is not an array, or if <code>$each</code> modifier is not an array.</li> </ul> <p>Example:</p> <pre><code>// Assuming doc = { categories: [\"news\"] }\nupdateEngine._applyAddToSet(doc, { categories: 'tech' });\n// doc is now: { categories: [\"news\", \"tech\"] }\n\nupdateEngine._applyAddToSet(doc, { categories: 'news' }); // no change\n// doc is still: { categories: [\"news\", \"tech\"] }\n\nupdateEngine._applyAddToSet(doc, { categories: { $each: ['sports', 'tech'] } });\n// doc is now: { categories: [\"news\", \"tech\", \"sports\"] }\n</code></pre>"},{"location":"developers/UpdateEngine/#each-modifier-in-array-operators","title":"<code>$each</code> Modifier in Array Operators","text":"<p>For array operators like <code>$push</code> and <code>$addToSet</code>, the <code>$each</code> modifier allows multiple values to be added at once. The <code>UpdateEngine</code> enforces that the value of <code>$each</code> must be an array. If <code>$each</code> is not an array, an <code>ErrorHandler.ErrorTypes.INVALID_QUERY</code> error is thrown. This ensures consistent and predictable behaviour when using array modifiers.</p>"},{"location":"developers/UpdateEngine/#shared-comparison-utilities","title":"Shared Comparison Utilities","text":"<p>Equality and operator evaluation logic is centralised in <code>ComparisonUtils</code>:</p> <ul> <li><code>ComparisonUtils.equals(a,b, { arrayContainsScalar })</code> \u2013 Deep equality with optional array membership semantics (membership disabled in update context for set uniqueness; strict structural equality is used).</li> <li><code>ComparisonUtils.compareOrdering(a,b)</code> \u2013 Ordering for numbers, strings, Dates.</li> <li><code>ComparisonUtils.applyOperators(actual, { $gt:5, $lt:10 })</code> \u2013 AND evaluation of supported operators (<code>$eq</code>, <code>$gt</code>, <code>$lt</code>).</li> <li><code>ComparisonUtils.subsetMatch(candidate, predicate)</code> \u2013 Shallow subset + field-level operator predicates used by <code>$pull</code> for object criteria.</li> </ul> <p><code>UpdateEngine</code> deliberately disables array membership semantics when enforcing uniqueness for <code>$addToSet</code> and when comparing primitives for <code>$pull</code> (strict equality only). This preserves prior behaviour while enabling richer predicate logic via subset match.</p>"},{"location":"developers/UpdateEngine/#utility-methods","title":"Utility Methods","text":""},{"location":"developers/UpdateEngine/#_getfieldvaluedocument-fieldpath","title":"<code>_getFieldValue(document, fieldPath)</code>","text":"<p>Retrieves a value from a document using a dot-notation path.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to read from.</li> <li><code>fieldPath</code> (String): The dot-notation path to the field (e.g., <code>\"address.city\"</code>).</li> </ul> <p>Returns:</p> <ul> <li><code>*</code>: The value at the specified path, or <code>undefined</code> if the path does not exist.</li> </ul> <p>Example:</p> <pre><code>const doc = { user: { name: 'John', address: { city: 'New York' } } };\nconst cityName = updateEngine._getFieldValue(doc, 'user.address.city'); // \"New York\"\nconst zipCode = updateEngine._getFieldValue(doc, 'user.address.zip'); // undefined\n</code></pre>"},{"location":"developers/UpdateEngine/#_setfieldvaluedocument-fieldpath-value","title":"<code>_setFieldValue(document, fieldPath, value)</code>","text":"<p>Sets a value in a document using a dot-notation path. Creates nested objects as needed if they don't exist along the path.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>fieldPath</code> (String): The dot-notation path to the field.</li> <li><code>value</code> (*): The value to set at the specified path.</li> </ul> <p>Example:</p> <pre><code>let doc = { user: { name: 'Jane' } };\nupdateEngine._setFieldValue(doc, 'user.contact.email', 'jane@example.com');\n// doc is now:\n// { user: { name: \"Jane\", contact: { email: \"jane@example.com\" } } }\n\nupdateEngine._setFieldValue(doc, 'user.age', 30);\n// doc is now:\n// { user: { name: \"Jane\", age: 30, contact: { email: \"jane@example.com\" } } }\n</code></pre>"},{"location":"developers/UpdateEngine/#_unsetfieldvaluedocument-fieldpath","title":"<code>_unsetFieldValue(document, fieldPath)</code>","text":"<p>Removes a field or array element at a given dot-notation path.</p> <p>Parameters:</p> <ul> <li><code>document</code> (Object): The document to modify.</li> <li><code>fieldPath</code> (String): The dot-notation path of the field or element to remove.</li> </ul> <p>Example:</p> <pre><code>let doc = { user: { name: 'Jane', age: 30, temp: 'delete me' } };\nupdateEngine._unsetFieldValue(doc, 'user.temp');\n// doc is now: { user: { name: \"Jane\", age: 30 } }\n\n// For arrays\nlet doc2 = { items: ['a', 'b', 'c'] };\nupdateEngine._unsetFieldValue(doc2, 'items.1');\n// doc2 is now: { items: [\"a\", undefined, \"c\"] } // preserves array length\n</code></pre>"},{"location":"developers/UpdateEngine/#usage-examples","title":"Usage Examples","text":""},{"location":"developers/UpdateEngine/#applying-multiple-operators","title":"Applying Multiple Operators","text":"<p>The <code>UpdateEngine</code> can apply several operators in a single <code>applyOperators</code> call.</p> <pre><code>const updateEngine = new UpdateEngine();\nlet product = {\n  name: 'Laptop',\n  price: 1200,\n  stock: 10,\n  features: ['SSD', '16GB RAM'],\n  ratings: []\n};\n\nconst updates = {\n  $set: { status: 'available', 'details.manufacturer': 'TechCorp' },\n  $inc: { stock: -1, views: 100 }, // 'views' will be created\n  $mul: { price: 0.9 }, // 10% discount\n  $push: { features: 'Backlit Keyboard' },\n  $addToSet: { tags: { $each: ['electronics', 'computer'] } }\n};\n\nproduct = updateEngine.applyOperators(product, updates);\n/*\nproduct is now:\n{\n  name: \"Laptop\",\n  price: 1080,\n  stock: 9,\n  features: [\"SSD\", \"16GB RAM\", \"Backlit Keyboard\"],\n  ratings: [],\n  status: \"available\",\n  details: { manufacturer: \"TechCorp\" },\n  views: 100,\n  tags: [\"electronics\", \"computer\"]\n}\n*/\n</code></pre>"},{"location":"developers/UpdateEngine/#updating-nested-fields","title":"Updating Nested Fields","text":"<p>Operators can target fields within nested objects using dot notation.</p> <pre><code>const updateEngine = new UpdateEngine();\nlet user = {\n  id: 1,\n  profile: {\n    name: 'Alice',\n    preferences: { theme: 'dark', notifications: true }\n  }\n};\n\nconst profileUpdates = {\n  $set: { 'profile.name': 'Alicia', 'profile.preferences.language': 'en' },\n  $unset: { 'profile.preferences.notifications': '' }\n};\n\nuser = updateEngine.applyOperators(user, profileUpdates);\n/*\nuser is now:\n{\n  id: 1,\n  profile: {\n    name: \"Alicia\",\n    preferences: { theme: \"dark\", language: \"en\" }\n  }\n}\n*/\n</code></pre>"},{"location":"developers/UpdateEngine/#array-manipulations","title":"Array Manipulations","text":"<p>Demonstrating various array operators.</p> <pre><code>const updateEngine = new UpdateEngine();\nlet article = {\n  title: 'GAS DB Guide',\n  authors: ['John'],\n  comments: [\n    { user: 'UserA', text: 'Great!' },\n    { user: 'UserB', text: 'Helpful.' }\n  ],\n  tags: ['database', 'apps script'],\n  scores: [10, 20, 30, 20, 40]\n};\n\nconst arrayUpdates = {\n  $push: { authors: 'Jane' },\n  $pull: { scores: 20 }, // Removes all instances of 20\n  $addToSet: { tags: 'guide' }\n};\n\narticle = updateEngine.applyOperators(article, arrayUpdates);\n/*\narticle is now:\n{\n  title: \"GAS DB Guide\",\n  authors: [\"John\", \"Jane\"],\n  comments: [\n    { user: \"UserA\", text: \"Great!\" },\n    { user: \"UserB\", text: \"Helpful.\" }\n  ],\n  tags: [\"database\", \"apps script\", \"guide\"],\n  scores: [10, 30, 40]\n}\n*/\n</code></pre>"},{"location":"developers/UpdateEngine/#error-handling","title":"Error Handling","text":"<p>The <code>UpdateEngine</code> uses <code>ErrorHandler.ErrorTypes.INVALID_QUERY</code> for most operational errors, such as:</p> <ul> <li>Applying an operator to a field of an incompatible type (e.g., <code>$inc</code> on a string).</li> <li>Using an invalid operator structure (e.g., <code>$each</code> modifier not being an array).</li> <li>Providing an empty <code>updateOps</code> object or one with no valid <code>$</code>-prefixed operators to <code>applyOperators</code>.</li> <li>Encountering an unknown update operator.</li> </ul> <p>It also uses <code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code> for invalid or missing arguments, such as when required parameters are not provided or are of the wrong type.</p> <p>Refer to <code>ErrorHandler.js</code> for details on error objects and codes.</p>"},{"location":"developers/UpdateEngine/#private-validation-methods","title":"Private Validation Methods","text":"<p>The <code>UpdateEngine</code> class includes several private validation methods to ensure robust error handling and input correctness. These methods are invoked internally before or during operator application:</p> <ul> <li><code>_validateApplyOperatorsInputs(document, updateOps)</code>: Ensures both arguments are valid objects.</li> <li><code>_validateUpdateOperationsNotEmpty(updateOps)</code>: Ensures the update operations object is not empty.</li> <li><code>_validateOperationsNotEmpty(ops, operatorName)</code>: Ensures the operator-specific operations object is not empty.</li> <li><code>_validateNumericValue(value, fieldPath, operation)</code>: Ensures a value is numeric for arithmetic operations.</li> <li><code>_validateCurrentFieldNumeric(value, fieldPath, operation)</code>: Ensures the current field value is numeric before arithmetic operations.</li> <li><code>_validateArrayValue(value, fieldPath, operation)</code>: Ensures a value is an array for array operations.</li> <li><code>_validateComparableValues(currentValue, newValue, fieldPath, operation)</code>: Ensures two values can be compared (same type or both numeric).</li> </ul> <p>These methods throw <code>ErrorHandler.ErrorTypes.INVALID_ARGUMENT</code> or <code>INVALID_QUERY</code> as appropriate, providing clear error messages for invalid input or misuse of operators.</p>"},{"location":"developers/UpdateEngine/#best-practices","title":"Best Practices","text":"<ul> <li>Validate inputs: Ensure the <code>updateOps</code> object is well-formed before passing it to <code>applyOperators</code>.</li> <li>Understand operator behaviour: Be familiar with how each MongoDB operator functions, especially with edge cases like non-existent fields or type mismatches. The <code>UpdateEngine</code> aims to mimic MongoDB behaviour.</li> <li>Nested paths: Use dot notation carefully for nested fields. The <code>_setFieldValue</code> utility will create intermediate objects if they don't exist when using <code>$set</code>. Other operators might behave differently if parent paths are missing.</li> <li>Array operations: Be mindful of how array operators like <code>$pull</code> match elements (subset field predicate for objects; supports basic comparison operators at field level).</li> <li>Performance: For very large documents or frequent updates, consider the performance implications, as each operation involves traversing and potentially restructuring parts of the document.</li> </ul>"},{"location":"developers/UpdateEngine/#dot-notation-and-nested-paths","title":"Dot Notation and Nested Paths","text":"<p>The <code>UpdateEngine</code> supports dot notation for targeting nested fields in documents (e.g., <code>profile.name</code>).</p> <ul> <li>The <code>_setFieldValue</code> utility will create intermediate objects as needed when using <code>$set</code> or similar operators.</li> <li>For other operators, if a parent path does not exist, behaviour may differ:</li> <li><code>$inc</code>, <code>$mul</code>, <code>$min</code>, <code>$max</code> will create the field if it does not exist, but only if the operation is valid for the value type.</li> <li><code>$unset</code> will silently do nothing if the path does not exist.</li> <li>Array operators (<code>$push</code>, <code>$pull</code>, <code>$addToSet</code>) will throw an error if the target is not an array or does not exist (unless the operator is designed to create the array).</li> <li>Edge cases: If an intermediate object in the path is not an object (e.g., a string or number), an error will be thrown.</li> </ul> <p>Careful use of dot notation is recommended to avoid unexpected behaviour, especially with deeply nested or missing paths.</p>"},{"location":"developers/UpdateEngine/#enhanced-pull-semantics-mongo-fidelity-subset-matching","title":"Enhanced <code>$pull</code> Semantics (Mongo Fidelity Subset Matching)","text":"<p>The <code>$pull</code> operator implementation has been extended beyond strict deep equality to align more closely with MongoDB behaviour:</p>"},{"location":"developers/UpdateEngine/#matching-rules","title":"Matching Rules","text":"<ul> <li>Primitive / Array Criterion: If the criterion is a primitive (string/number/boolean/null/Date) or an array, all array elements strictly equal (deep equality for arrays) to the criterion are removed.</li> <li>Object Criterion (Field Predicate): If the criterion is a plain object whose keys do not all start with <code>$</code>, it is treated as a subset predicate. An array element that is an object matches if it contains all specified fields with matching values (deep equality per field). Extra fields on the element do not prevent a match.</li> <li>Field-Level Operator Objects: Within an object criterion, a field value may itself be an operator object (all keys start with <code>$</code>). Supported operators: <code>$eq</code>, <code>$gt</code>, <code>$lt</code>. All operators inside that object must succeed. Example: <code>{ items: { price: { $lt: 10 }, sku: 'A1' } }</code> removes all objects whose <code>price &lt; 10</code> AND <code>sku === 'A1'</code>.</li> <li>Top-Level Operator Object: A criterion whose keys all start with <code>$</code> (e.g. <code>{ $gt: 5 }</code>) applies only to primitive (or Date) elements. If the array elements are objects, this criterion does not match (intentional simplification documented here).</li> </ul>"},{"location":"developers/UpdateEngine/#non-matching-no-op-cases","title":"Non-Matching / No-Op Cases","text":"<ul> <li>Target field missing or not an array: Silent no-op (no error, <code>modifiedCount</code> = 0).</li> <li>Object criterion referencing fields absent on the element: Non-match (element retained).</li> <li>Operator predicates on incomparable types (e.g. <code>$gt</code> between string and number) return false (element retained).</li> </ul>"},{"location":"developers/UpdateEngine/#date-handling","title":"Date Handling","text":"<p>Dates are compared using their millisecond timestamps. <code>$gt</code> / <code>$lt</code> comparisons on Dates work when both sides are Dates. Field-level equality uses deep time equality.</p>"},{"location":"developers/UpdateEngine/#null-handling","title":"Null Handling","text":"<p><code>null</code> criterion matches only <code>null</code> elements (or object field values equal to <code>null</code> in subset predicates). Undefined values do not match <code>null</code>.</p>"},{"location":"developers/UpdateEngine/#examples","title":"Examples","text":"<p>Remove subset by key:</p> <pre><code>// items: [{ sku:'A', qty:1, price:5 }, { sku:'A', qty:2, price:5 }, { sku:'B', qty:1, price:9 }]\nupdateEngine._applyPull(doc, { items: { sku: 'A' } });\n// Removes both objects with sku A.\n</code></pre> <p>Mixed field + operator:</p> <pre><code>updateEngine._applyPull(doc, { items: { sku: 'A', price: { $lt: 6 } } });\n</code></pre> <p>Primitive operator on numeric array:</p> <pre><code>updateEngine._applyPull(doc, { scores: { $gt: 90 } });\n</code></pre> <p>Top-level operator against object elements (no removal):</p> <pre><code>updateEngine._applyPull(doc, { items: { $gt: 5 } }); // items are objects -&gt; no match\n</code></pre>"},{"location":"developers/UpdateEngine/#limitations-deferred-features","title":"Limitations / Deferred Features","text":"<ul> <li>Unsupported operators within <code>$pull</code> field-level predicates: <code>$in</code>, <code>$nin</code>, <code>$ne</code>, logical operators (<code>$and</code>, <code>$or</code>). These are candidates for future enhancement.</li> <li>No nested logical composition inside a single field predicate (e.g. <code>{ price: { $gt: 5, $lt: 10 } }</code> works, but <code>{ $or: [...] }</code> at field level inside object predicate is not yet supported).</li> <li>Top-level logical operators inside <code>$pull</code> criterion not yet supported.</li> </ul>"},{"location":"developers/UpdateEngine/#rationale","title":"Rationale","text":"<p>The subset + operator approach balances fidelity with simplicity, deferring more complex logical parsing until query/operator evaluation logic is centralised (see planned shared comparator utility).</p>"},{"location":"developers/UpdateEngine/#testing-strategy-summary","title":"Testing Strategy Summary","text":"<p>Validation tests cover:</p> <ul> <li>Subset removal</li> <li>Mixed field + operator</li> <li>Exact object removal regression</li> <li>Non-match cases (missing field, top-level operator vs object element)</li> <li>Null removal</li> <li>Date operator removal</li> <li>No-op modifiedCount scenarios</li> </ul> <p>Refer to <code>old_tests/validation/04_ArrayUpdateOperators.js</code> for concrete examples.</p>"},{"location":"release-notes/release-notes-v0.0.3/","title":"Version 0.0.3","text":""},{"location":"release-notes/release-notes-v0.0.3/#jsondbapp-v003-patch-release","title":"JsonDbApp v0.0.3 \u2014 Patch release","text":"<p>Release date: 2025-12-08</p>"},{"location":"release-notes/release-notes-v0.0.3/#summary","title":"Summary","text":"<p>Introduce conditional handling for backup index file creation and removal based on the <code>backupOnInitialise</code> configuration. Includes a test suite to validate this behaviour and updated package dependencies.</p>"},{"location":"release-notes/release-notes-v0.0.3/#highlights","title":"Highlights","text":"<ul> <li>Conditional backup index handling during collection creation/removal controlled via <code>backupOnInitialise</code>.</li> <li>New tests validating the backup logic and index file handling.</li> <li>Package dependency updates and minor fixes to Database optional chaining and test harnesses.</li> </ul>"},{"location":"release-notes/release-notes-v0.0.3/#prs-merged","title":"PRs merged","text":""},{"location":"release-notes/release-notes-v0.0.3/#18-add-conditional-backup-index-handling-and-tests-merged-2025-12-08","title":"18 \u2014 Add conditional backup index handling and tests (merged: 2025-12-08)","text":""},{"location":"release-notes/release-notes-v0.0.3/#full-changelog","title":"Full changelog","text":"<ul> <li>e5dc0e2 \u2014 feat: Add conditional backup index file handling during collection creation and removal</li> <li>a547e06 \u2014 feat: Add backup index test suite to validate backupOnInitialise behavior</li> <li>c2842b1 \u2014 feat: Update package.json and package-lock.json to include clasp dependency and version updates</li> <li>7795010 \u2014 fix: Remove clasp dependency and improve optional chaining in Database class</li> <li>ef6676d9 \u2014 fix: Update index file handling in backup tests to ensure correct file counting and listing</li> </ul>"},{"location":"release-notes/release-notes-v0.0.3/#upgrade-notes","title":"Upgrade notes","text":"<ul> <li>No breaking changes introduced in this patch.</li> <li>To enable automatic backup index creation during initialisation, set <code>backupOnInitialise: true</code> in <code>DatabaseConfig</code>.</li> </ul>"},{"location":"release-notes/release-notes-v0.0.4/","title":"Version 0.0.4","text":""},{"location":"release-notes/release-notes-v0.0.4/#jsondbapp-v004-patch-release","title":"JsonDbApp v0.0.4 \u2014 Patch release","text":"<p>Release date: 2026-01-28</p>"},{"location":"release-notes/release-notes-v0.0.4/#summary","title":"Summary","text":"<p>Enhancements to collection name sanitisation (now configurable), improved local testing support via GAS API mocks and recorder stubs, documentation and development environment improvements, and a small bug fix correcting the error type thrown for corrupted collection metadata. Includes test updates and tooling additions to make local development and testing easier.</p> <p>Get copies of the latest scripts here</p>"},{"location":"release-notes/release-notes-v0.0.4/#highlights","title":"Highlights","text":"<ul> <li>Add configurable collection name sanitisation with a new option to control sanitisation behaviour.</li> <li>Add GAS API mock plan and local Node-based stubs to support local testing of GAS integrations.</li> <li>Fix: use <code>TypeError</code> when a corrupted <code>collections</code> property is detected (replacing a generic <code>Error</code>).</li> <li>Improved developer experience: add a Dev Container and tooling to simplify local setup and testing.</li> <li>Tests updated and new/modified suites to cover the above behaviour and improve reliability.</li> </ul>"},{"location":"release-notes/release-notes-v0.0.4/#prs-merged","title":"PRs merged","text":""},{"location":"release-notes/release-notes-v0.0.4/#22-enhance-collection-name-sanitisation-with-configurable-option-merged","title":"22 \u2014 Enhance collection name sanitisation with configurable option (merged)","text":""},{"location":"release-notes/release-notes-v0.0.4/#19-add-gas-api-mock-plan-and-local-node-based-stubs-merged","title":"19 \u2014 Add GAS API mock plan and local Node-based stubs (merged)","text":""},{"location":"release-notes/release-notes-v0.0.4/#full-changelog","title":"Full changelog","text":"<ul> <li>d286fea \u2014 feat: Enhance collection name sanitisation with configurable option (#22)</li> <li>6ce793c \u2014 feat: Add GAS API mock plan and local Node-based stubs (#19)</li> <li>92ace0f \u2014 docs: Update README with project copy instructions and clarify test versions</li> <li>7910a72 \u2014 fix: change error type from Error to TypeError for corrupted collections property</li> <li>Added: <code>.devcontainer/</code> and Dev Container configuration, plus improved CI/dev tooling</li> <li>Added: <code>tools/gas-mocks/</code> and <code>tools/gas-recorder/</code> to support local testing and recordings</li> <li>Added: <code>src/appsscript.json</code> and small project configuration updates</li> <li>Tests: Updated and added several unit and integration tests covering Database and Collection behaviours</li> <li>Misc: package updates and documentation tweaks</li> </ul>"},{"location":"release-notes/release-notes-v0.0.4/#upgrade-notes","title":"Upgrade notes","text":"<ul> <li>No breaking changes introduced.</li> <li>To enable the new sanitisation behaviour, check <code>DatabaseConfig</code> for the collection name sanitisation option and adjust as needed.</li> </ul>"}]}